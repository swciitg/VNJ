diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/barrier.h linux-2.6.29/arch/mips/include/asm/barrier.h
--- linux-2.6.29.ref/arch/mips/include/asm/barrier.h	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/include/asm/barrier.h	2011-05-24 12:39:48.704295664 -0700
@@ -78,6 +78,31 @@
 #define __sync()	do { } while(0)
 #endif
 
+#if defined(CONFIG_TANGO2)
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#define __fast_iob()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)(CKSEG1+MEM_BASE_dram_controller_0+FM_RESERVED))	\
+		: "memory")
+#elif defined(CONFIG_TANGO3)
+#define __fast_iob()				\
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)(CKSEG1+CPU_REMAP_SPACE))	\
+		: "memory")
+#else
 #define __fast_iob()				\
 	__asm__ __volatile__(			\
 		".set	push\n\t"		\
@@ -88,6 +113,7 @@
 		: /* no output */		\
 		: "m" (*(int *)CKSEG1)		\
 		: "memory")
+#endif
 
 #define fast_wmb()	__sync()
 #define fast_rmb()	__sync()
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/bootinfo.h linux-2.6.29/arch/mips/include/asm/bootinfo.h
--- linux-2.6.29.ref/arch/mips/include/asm/bootinfo.h	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/include/asm/bootinfo.h	2011-05-24 12:39:48.704295664 -0700
@@ -57,6 +57,11 @@
 #define	MACH_MIKROTIK_RB532	0	/* Mikrotik RouterBoard 532 	*/
 #define MACH_MIKROTIK_RB532A	1	/* Mikrotik RouterBoard 532A 	*/
 
+/*
+ * Valid machtype for group SIGMADESIGNS
+ */
+#define MACH_TANGOX		1	/* TangoX */
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 extern char *system_type;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/cacheflush.h linux-2.6.29/arch/mips/include/asm/cacheflush.h
--- linux-2.6.29.ref/arch/mips/include/asm/cacheflush.h	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/include/asm/cacheflush.h	2011-05-24 12:39:48.704295664 -0700
@@ -57,11 +57,7 @@
 		__flush_anon_page(page, vmaddr);
 }
 
-static inline void flush_icache_page(struct vm_area_struct *vma,
-	struct page *page)
-{
-}
-
+extern void (*flush_icache_page)(struct vm_area_struct *vma, struct page *page);
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
 extern void (*local_flush_icache_range)(unsigned long start, unsigned long end);
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/delay.h linux-2.6.29/arch/mips/include/asm/delay.h
--- linux-2.6.29.ref/arch/mips/include/asm/delay.h	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/arch/mips/include/asm/delay.h	2011-05-24 12:39:48.704295664 -0700
@@ -98,7 +98,12 @@
 
 #define __udelay_val cpu_data[raw_smp_processor_id()].udelay_val
 
+#ifdef CONFIG_TANGOX
+void tangox_udelay(unsigned usec);
+#define udelay(usecs) tangox_udelay(usecs)
+#else
 #define udelay(usecs) __udelay((usecs), __udelay_val)
+#endif
 
 /* make sure "usecs *= ..." in udelay do not overflow. */
 #if HZ >= 1000
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/dma.h linux-2.6.29/arch/mips/include/asm/dma.h
--- linux-2.6.29.ref/arch/mips/include/asm/dma.h	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/include/asm/dma.h	2011-05-24 12:39:48.704295664 -0700
@@ -87,6 +87,8 @@
 #if defined(CONFIG_SGI_IP22) || defined(CONFIG_SGI_IP28)
 /* don't care; ISA bus master won't work, ISA slave DMA supports 32bit addr */
 #define MAX_DMA_ADDRESS		PAGE_OFFSET
+#elif defined(CONFIG_TANGOX)
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x20000000)
 #else
 #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)
 #endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/io.h linux-2.6.29/arch/mips/include/asm/io.h
--- linux-2.6.29.ref/arch/mips/include/asm/io.h	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/include/asm/io.h	2011-05-24 12:39:48.704295664 -0700
@@ -337,6 +337,7 @@
 			local_irq_restore(__flags);			\
 	} else								\
 		BUG();							\
+	__sync();                                                       \
 }									\
 									\
 static inline type pfx##read##bwlq(const volatile void __iomem *mem)	\
@@ -388,6 +389,7 @@
 	BUILD_BUG_ON(sizeof(type) > sizeof(unsigned long));		\
 									\
 	*__addr = __val;						\
+	__sync();                                                       \
 	slow;								\
 }									\
 									\
@@ -534,6 +536,15 @@
 	memcpy((void __force *) dst, src, count);
 }
 
+/* Create a virtual mapping cookie for an IO port range */
+extern void __iomem *ioport_map(unsigned long port, unsigned int nr);
+extern void ioport_unmap(void __iomem *);
+
+/* Create a virtual mapping cookie for a PCI BAR (memory or IO) */
+struct pci_dev;
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
 /*
  * The caches on some architectures aren't dma-coherent and have need to
  * handle this in software.  There are three types of operations that
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/irq.h linux-2.6.29/arch/mips/include/asm/mach-tango2/irq.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/irq.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango2/irq.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,8 @@
+
+#ifndef __ASM_MACH_TANGO2_IRQ_H
+#define __ASM_MACH_TANGO2_IRQ_H
+
+#define MIPS_CPU_IRQ_BASE 0
+#define NR_IRQS 256
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/param.h linux-2.6.29/arch/mips/include/asm/mach-tango2/param.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/param.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango2/param.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,5 @@
+
+#ifndef __ASM_MACH_TANGO2_PARAM_H
+#define __ASM_MACH_TANGO2_PARAM_H
+
+#endif /* __ASM_MACH_TANGO2_PARAM_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/spaces.h linux-2.6.29/arch/mips/include/asm/mach-tango2/spaces.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/spaces.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango2/spaces.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,33 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO2_SPACES_H
+#define _ASM_MACH_TANGO2_SPACES_H
+
+#define PHYS_OFFSET             0x00000000UL
+#define CAC_BASE		0x80000000UL
+#define IO_BASE			0xa0000000UL
+#define UNCAC_BASE		0xa0000000UL
+#define MAP_BASE		0xc0000000UL
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO2_SPACES_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/war.h linux-2.6.29/arch/mips/include/asm/mach-tango2/war.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango2/war.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango2/war.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,26 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_TANGO2_WAR_H
+#define __ASM_MIPS_MACH_TANGO2_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_TANGO2_WAR_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/irq.h linux-2.6.29/arch/mips/include/asm/mach-tango3/irq.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/irq.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango3/irq.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,8 @@
+
+#ifndef __ASM_MACH_TANGO3_IRQ_H
+#define __ASM_MACH_TANGO3_IRQ_H
+
+#define MIPS_CPU_IRQ_BASE 0
+#define NR_IRQS 256
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/param.h linux-2.6.29/arch/mips/include/asm/mach-tango3/param.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/param.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango3/param.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,5 @@
+
+#ifndef __ASM_MACH_TANGO3_PARAM_H
+#define __ASM_MACH_TANGO3_PARAM_H
+
+#endif /* __ASM_MACH_TANGO3_PARAM_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/spaces.h linux-2.6.29/arch/mips/include/asm/mach-tango3/spaces.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/spaces.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango3/spaces.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,33 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Sigma Designs, Inc.
+ * Copyright (C) 1994 - 1999, 2000, 03, 04 Ralf Baechle
+ * Copyright (C) 2000, 2002  Maciej W. Rozycki
+ * Copyright (C) 1990, 1999, 2000 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_MACH_TANGO3_SPACES_H
+#define _ASM_MACH_TANGO3_SPACES_H
+
+#define PHYS_OFFSET             0x00000000UL
+#define CAC_BASE		0x80000000UL
+#define IO_BASE			0xa0000000UL
+#define UNCAC_BASE		0xa0000000UL
+#define MAP_BASE		0xc0000000UL
+
+/*
+ * This handles the memory map.
+ * We handle pages at KSEG0 for kernels with 32 bit address space.
+ */
+#define PAGE_OFFSET		0x80000000UL
+
+/*
+ * Memory above this physical address will be considered highmem.
+ */
+#ifndef HIGHMEM_START
+#define HIGHMEM_START		0x20000000UL
+#endif
+
+#endif /* __ASM_MACH_TANGO3_SPACES_H */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/war.h linux-2.6.29/arch/mips/include/asm/mach-tango3/war.h
--- linux-2.6.29.ref/arch/mips/include/asm/mach-tango3/war.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/mach-tango3/war.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,26 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_TANGO3_WAR_H
+#define __ASM_MIPS_MACH_TANGO3_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_TANGO3_WAR_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/hardware.h linux-2.6.29/arch/mips/include/asm/tango2/hardware.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/hardware.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,122 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+
+/* UART0 */
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+/* UART1 */
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+/* IDE interrupts */
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+/* MBUS interface */
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+/* GPIO */
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+/* UART GPIO */
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	7   	/* 2^7 = 128MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<MAX_LOG2_PCIMEM_MAP)*7)>>3)	/* Max 112MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x10000000UL)   /* base address of EM86xx PCI slave */
+
+/* Peripheral bus Registers */
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+/* Bus Master IDE */
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+#ifndef MAX_KERNEL_MEMSIZE
+#define MAX_KERNEL_MEMSIZE	0x10000000UL
+#endif
+
+#ifndef __ASSEMBLY__
+/* Physical address mapping */
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if (physaddr >= MEM_BASE_dram_controller_0)
+		return(physaddr); /* for Tango2, it's the same */
+	else if (physaddr >= CPU_remap4_address) 
+		return(gbus_read_reg32(REG_BASE_cpu_block + CPU_remap4) + (physaddr - CPU_remap4_address));
+	else if (physaddr >= CPU_remap3_address) 
+		return(gbus_read_reg32(REG_BASE_cpu_block + CPU_remap3) + (physaddr - CPU_remap3_address));
+	else if (physaddr >= CPU_remap2_address) 
+		return(gbus_read_reg32(REG_BASE_cpu_block + CPU_remap2) + (physaddr - CPU_remap2_address));
+#endif
+	return(physaddr); 
+}
+
+/* Inverted physical address mapping */
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+#ifndef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	if ((mapaddr >= MEM_BASE_dram_controller_0) && (mapaddr < MEM_BASE_dram_controller_1))
+		return(mapaddr); /* for Tango2, it's the same */
+	else {
+		unsigned long remap;
+		remap = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap4);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap4_address + (mapaddr - remap));
+		remap = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap3);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap3_address + (mapaddr - remap));
+		remap = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap2);
+		if ((mapaddr >= remap) && (mapaddr < (remap + 0x04000000)))
+			return(CPU_remap2_address + (mapaddr - remap));
+	}
+#endif
+	return(mapaddr); /* for Tango2, it's the same */
+}
+#endif
+		
+#endif /* __HARDWARE_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/memcfg.h linux-2.6.29/arch/mips/include/asm/tango2/memcfg.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/memcfg.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/memcfg.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,44 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* For more memcfg operations */
+
+#ifndef _MEMCFG_H_
+#define _MEMCFG_H_
+
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_dram.h>
+
+static inline int is_valid_memcfg(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	if ((memcfg_ptr->signature) != MEMCFG_SIGNATURE)
+		return(0);
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	return((sum == 0) ? 1 : 0);
+}
+
+static inline void gen_memcfg_checksum(memcfg_t *memcfg_ptr)
+{
+	unsigned int sum, i, *ptr;
+
+	memcfg_ptr->checksum = 0;
+	for (sum = i = 0, ptr = (unsigned int *)memcfg_ptr;
+		i < (sizeof(memcfg_t) / sizeof(unsigned int)); i++, ptr++)
+		sum += (*ptr);
+	memcfg_ptr->checksum = ~sum + 1;
+}
+
+#endif /* _MEMCFG_H_ */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/rmdefs.h linux-2.6.29/arch/mips/include/asm/tango2/rmdefs.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/rmdefs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/rmdefs.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2api.h linux-2.6.29/arch/mips/include/asm/tango2/tango2api.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2api.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/tango2api.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,115 @@
+/*
+ * include/asm-mips/tango2/tangoa2pi.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango2/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA1, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_UNUSED1, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int canwait);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_notification(unsigned int regbase, mbus_irq_handler_t handler, void *arg);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+void em86xx_mbus_reset(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+
+#define NUM_TANGOX_MUTEX	4
+#define MUTEX_PBI		0
+
+int tangox_mutex_lock(unsigned int idx);
+int tangox_mutex_unlock(unsigned int idx);
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2_gbus.h linux-2.6.29/arch/mips/include/asm/tango2/tango2_gbus.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2_gbus.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/tango2_gbus.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,147 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+  Refer to bug #3644.
+
+  TLB-based implementation works on the ranges:
+  [0x00000000..0x20000000[ access thru kseg1
+  [0x20000000..0x2xxxxxxx (size  of dram1, a  parameter of ioremap())[
+  access thru tlb. Outside: unpredictable/oops.
+
+  Remap-based implementation does:
+  00xy b27b26..b0 to 101y(b27|x)b26..b0.
+  and works  everywhere excepted ranges:  [0x18000000..0x20000000[ and
+  [0x28000000..0xffffffff]
+
+  Test with
+  {
+	volatile int q=gbus_read_uint32(pGBus,0x1020212c); // correct
+	q=gbus_read_uint32(pGBus,0x1f20212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2020212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2720212c);              // correct
+	q=gbus_read_uint32(pGBus,0x2820212c);              // incorrect
+	q=gbus_read_uint32(pGBus,0x2f20212c);              // incorrect
+  }
+*/
+
+#ifndef __TANGO2_GBUS_H
+#define __TANGO2_GBUS_H
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	ext	\\res, \\addr, 29, 1				\n"
+	"	bnez	\\res, 1f					\n"
+	"	lui	\\tmp, 0xa000					\n"
+	"	or	\\res, \\tmp, \\addr				\n"
+	"	j	2f						\n"
+	"	nop							\n"
+	"1:								\n"
+	"	lui	\\tmp, 0x2000					\n"
+	"	sub	\\res, \\addr, \\tmp				\n"
+	"	lw	\\tmp, em86xx_tlb_dram1_map_base		\n"
+	"	add	\\res, \\tmp					\n"
+	"2:								\n"
+	"	.endm");
+
+#else
+
+__asm__ (
+	"	.macro gbus_swizzle_addr res tmp addr			\n"
+	"	rotr	\\res, \\addr, 29				\n"
+	"	ins	\\res, \\res, 30, 1				\n"
+	"	or	\\res, 5					\n"
+	"	rotr	\\res, 3					\n"
+	"	.endm");
+#endif
+
+
+/*
+ * we just want to set kseg1 bit, most of the time address is known at
+ * compile time, so this will usually be reduced to 2 instructions
+ */
+
+#define BUILD_GBUS_READ(size)						\
+static inline RMuint32 gbus_read_dram_uint##size(struct gbus *pgbus,	\
+					    RMuint32 byte_address)	\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		return *((volatile RMuint##size *)KSEG1ADDR(byte_address)); \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		return *((volatile RMuint##size *)res);			\
+	}								\
+}
+
+BUILD_GBUS_READ(8);
+BUILD_GBUS_READ(16);
+BUILD_GBUS_READ(32);
+
+#define BUILD_GBUS_WRITE(size)						\
+static inline void gbus_write_dram_uint##size(struct gbus *pgbus,	\
+				     RMuint32 byte_address,		\
+				     RMuint##size data)			\
+{									\
+	if (__builtin_constant_p(byte_address)) {			\
+		if ((byte_address & 0x70000000) == 0x20000000) {	\
+			byte_address &= ~0x20000000;			\
+			byte_address |= 0x08000000;			\
+		}							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data; \
+	} else {							\
+		RMuint32 res, tmp;					\
+									\
+		__asm__ __volatile(					\
+			"gbus_swizzle_addr\t%0 %1 %2\n"			\
+			: "=&r" (res), "=&r" (tmp) : "r" (byte_address)); \
+		*((volatile RMuint##size *)res) = data;			\
+	}								\
+}
+
+BUILD_GBUS_WRITE(8);
+BUILD_GBUS_WRITE(16);
+BUILD_GBUS_WRITE(32);
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_read_reg32(r)      __raw_readl((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg16(r)      __raw_readw((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg8(r)       __raw_readb((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg32(r, v)  __raw_writel(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg16(r, v)  __raw_writew(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg8(r, v)   __raw_writeb(v, (volatile void __iomem *)KSEG1ADDR(r))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO2_GBUS_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2.h linux-2.6.29/arch/mips/include/asm/tango2/tango2.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/tango2.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,65 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   tango2.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO2_H__
+#define __TANGO2_H__
+#include <asm/tango2/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/emhwlib_lram.h>
+#include <asm/tango2/emhwlib_resources_tango2.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#endif
+/* Baudrate setting */
+#if defined(CONFIG_TANGO2_SMP863X)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO2_SMP863X)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO2_SMP863X */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO2_SMP863X)
+#define SYS_clkgen_pll        SYS_clkgen3_pll
+#endif
+
+#define RMCHIP_ID_SMP8634 (8634)
+
+#endif // __TANGO2_H__
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2_pci.h linux-2.6.29/arch/mips/include/asm/tango2/tango2_pci.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2_pci.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/tango2_pci.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,75 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO2_PCI_H
+#define __TANGO2_PCI_H
+
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+
+#define PCIEM86XX_PCIFAULT_INTR		((IRQ_CONTROLLER_IRQ_BASE) + \
+						(LOG2_CPU_PCI_FAULT_INT))
+
+#define PCIEM86XX_ARBITER_LEVEL		0x00
+#define PCIEM86XX_ARBITER_GRANTTIMEOUT	0x10101010
+
+#define PCIEM86XX_IDSEL_MAX		0x05
+#define PCIEM86XX_IDSEL_BITS		0x03
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * read/write data  from/to the configuration space.  The  only way to
+ * know if there is a device is by checking that we did not generate a
+ * bus fault interrupt, so we need to mask them during the access.
+ */
+#define BUILD_TANGOX_CFG_ACCESS(pfx, __x)				\
+static inline int tangox_cfg_##pfx(void __iomem *addr, u32 *data)	\
+{									\
+	unsigned long flags, status;					\
+									\
+	local_irq_save(flags);						\
+									\
+	__x;								\
+	status = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3;		\
+	if (status) {							\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);			\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);			\
+		local_irq_restore(flags);				\
+		return 1;						\
+	}								\
+									\
+	local_irq_restore(flags);					\
+	return 0;							\
+}
+
+BUILD_TANGOX_CFG_ACCESS(read8, *data = readb(addr) & 0xff)
+BUILD_TANGOX_CFG_ACCESS(read16, *data = readw(addr) & 0xffff)
+BUILD_TANGOX_CFG_ACCESS(read32, *data = readl(addr))
+BUILD_TANGOX_CFG_ACCESS(write8, writeb(*data & 0xff, addr))
+BUILD_TANGOX_CFG_ACCESS(write16, writew(*data & 0xffff, addr))
+BUILD_TANGOX_CFG_ACCESS(write32, writel(*data, addr))
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2_usb.h linux-2.6.29/arch/mips/include/asm/tango2/tango2_usb.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango2/tango2_usb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango2/tango2_usb.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,39 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO2_USB_H
+#define __TANGO2_USB_H
+
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+
+#define TANGOX_EHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT)
+#define TANGOX_OHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+
+#define TANGOX_EHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE	(REG_BASE_host_interface + 0x1700)
+
+/*
+ * helpers to access USB registers
+ */
+#define RD_OHCI_REG32(r)	\
+		gbus_read_reg32(TANGOX_OHCI_BASE_ADDR + (r))
+
+#define WR_OHCI_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_OHCI_BASE_ADDR + (r), (v))
+
+#define RD_USB_REG32(r)	\
+		gbus_read_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r))
+
+#define WR_USB_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r), (v))
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango3/hardware.h linux-2.6.29/arch/mips/include/asm/tango3/hardware.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango3/hardware.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango3/hardware.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,149 @@
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+#ifndef __HARDWARE_H
+#define __HARDWARE_H
+
+#include <linux/version.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+
+/* UART0 */
+#define CPU_uart0_gpio_dir	    (CPU_UART0_base + CPU_UART_GPIODIR)
+#define CPU_uart0_gpio_data	    (CPU_UART0_base + CPU_UART_GPIODATA)
+#define CPU_uart0_gpio_mode	    (CPU_UART0_base + CPU_UART_GPIOMODE)
+
+/* UART1 */
+#define CPU_uart1_gpio_dir	    (CPU_UART1_base + CPU_UART_GPIODIR)
+#define CPU_uart1_gpio_data	    (CPU_UART1_base + CPU_UART_GPIODATA)
+#define CPU_uart1_gpio_mode	    (CPU_UART1_base + CPU_UART_GPIOMODE)
+
+/* UART2 */
+#define CPU_uart2_gpio_dir	    (CPU_UART2_base + CPU_UART_GPIODIR)
+#define CPU_uart2_gpio_data	    (CPU_UART2_base + CPU_UART_GPIODATA)
+#define CPU_uart2_gpio_mode	    (CPU_UART2_base + CPU_UART_GPIOMODE)
+
+#define MIPS_CPU_IRQ_BASE 0
+
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define IRQ_CONTROLLER_IRQ_BASE 8
+#define FIQ_CONTROLLER_IRQ_BASE 72
+#define IIQ_CONTROLLER_IRQ_BASE 136 // bit31 of iiq is linux irq 199
+#define IRQ_COUNT               64  // 64 interrupt sources
+#else
+#error "Unsupported Tango3 chip."
+#endif
+
+#define IRQ_SOFTINT                     (IRQ_CONTROLLER_IRQ_BASE+0)   // gnet compatibility
+/* IDE interrupts */
+#define IRQ_IDECTRL_IDEDMA	(LOG2_CPU_DMAIDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+#define IRQ_IDECTRL_IDE		(LOG2_CPU_IDE_INT + IRQ_CONTROLLER_IRQ_BASE)
+
+/* MBUS interface */
+#define MIF_add_offset		    0x0
+#define MIF_cnt_offset              (MIF_W0_CNT - MIF_W0_ADD) //0x04
+#define MIF_add2_skip_offset        (MIF_W0_SKIP - MIF_W0_ADD) //0x08
+#define MIF_cmd_offset              (MIF_W0_CMD - MIF_W0_ADD) //0x0c
+
+/* GPIO */
+#define GPIO_DIR_INPUT(gpio)        ((1 << (16 + (gpio))))
+#define GPIO_DIR_OUTPUT(gpio)       ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_SET(gpio)         ((1 << (16 + (gpio))) | (1 << (gpio)))
+#define GPIO_DATA_CLEAR(gpio)       ((1 << (16 + (gpio))))
+
+/* UART GPIO */
+#define UART_GPIO_DIR_INPUT(gpio)        ((1 << (8 + (gpio))))
+#define UART_GPIO_DIR_OUTPUT(gpio)       ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_SET(gpio)         ((1 << (8 + (gpio))) | (1 << (gpio)))
+#define UART_GPIO_DATA_CLEAR(gpio)       ((1 << (8 + (gpio))))
+
+/* PCI Memories */
+#define MEMORY_BASE_PCI_CONFIG      0x50000000UL  /* PCI configuration */
+#define MEMORY_BASE_PCI_IO          0x58000000UL  /* PCI I/O space */
+#define MEMORY_BASE_PCI_MEMORY      0x60000000UL  /* PCI Memory Base */
+
+#define MAX_LOG2_PCIMEM_MAP  	6   	/* 2^(6+3) = 512MB */
+#define MAX_PCIMEM_MAP_SIZE  	(((1<<(MAX_LOG2_PCIMEM_MAP+3))*7)>>3)	/* Max 448MB */
+
+#define PCIBIOS_MIN_MEM_EM86XX  (MEMORY_BASE_PCI_MEMORY + 0x40000000UL)   /* base address of EM86xx PCI slave */
+
+/* Peripheral bus Registers */
+#define HOST_pb0_base               0x0000
+#define HOST_pb_base_cs(n)          (HOST_pb0_base + (0x0200 * (n)))
+
+#define PB_timing_slot(n)	    (PB_timing0 + (0x04 * (n)))
+
+/* Bus Master IDE */
+#define REG_BASE_host_interface_BMIDE         (REG_BASE_host_interface + IDECTRL_pri_cmdblock)
+
+#define REG_BASE_host_interface_ISAIDE(x)  (REG_BASE_host_interface + HOST_pb_base_cs(x))
+
+/* Only applicable to Tango3 */
+#define SDND_MAGIC		0x4d474953      /* SIGM */
+#define SDND_MINORS		16
+#define SDND_MAX_CS		4
+#define KERNEL_SECTOR_SIZE	512
+
+#ifndef __ASSEMBLY__
+
+struct xenv_disk_marker
+{
+	unsigned int magic; 	/* magic# */
+	unsigned int cs;
+};
+
+#ifdef CONFIG_PRINTK
+int printk(const char * fmt, ...) __attribute__ ((format (printf, 1, 2)));
+#else
+static inline int printk(const char *s, ...) __attribute__ ((format (printf, 1, 2)));
+#endif
+
+#ifndef REMAP_IDX
+#define REMAP_IDX      (((CPU_REMAP_SPACE-CPU_remap2_address)/0x04000000UL)+2)
+#endif
+#ifndef MAX_KERNEL_MEMSIZE
+#define MAX_KERNEL_MEMSIZE	(0x1c000000UL-(((REMAP_IDX)-2)*0x04000000UL))
+#endif
+
+/* Physical address mapping */
+static inline unsigned long tangox_dma_address(unsigned long physaddr)
+{
+	extern unsigned long em8xxx_remap_registers[9];
+	extern unsigned long em8xxx_kmem_size;
+
+	if ((physaddr < CPU_REMAP_SPACE) || (physaddr >= (CPU_REMAP_SPACE + em8xxx_kmem_size))) {
+/*		printk("<3>" "dma_address conversion failure (0x%08lx in range 0x%08lx-0x%08lx)\n", */
+/*			physaddr, (unsigned long)CPU_REMAP_SPACE, (unsigned long)CPU_REMAP_SPACE + em8xxx_kmem_size); */
+		return(physaddr); /* use whatever is specified */
+	} else {
+		return(em8xxx_remap_registers[((physaddr & 0x1c000000UL) >> 26) + 1] + (physaddr & 0x03ffffffUL));
+	}
+}
+
+/* Inverted physical address mapping */
+static inline unsigned long tangox_inv_dma_address(unsigned long mapaddr)
+{
+	extern unsigned long em8xxx_remap_registers[9];
+	extern unsigned long em8xxx_kmem_size;
+	int i;
+	unsigned long msize = 0, offset = mapaddr & 0x03ffffffUL, base = mapaddr & 0xfc000000UL;
+	for (i = REMAP_IDX; (msize < em8xxx_kmem_size) && (i < 9); msize += 0x04000000, i++) {
+		if (base == em8xxx_remap_registers[i]) {	/* found the remap register to match */
+			if (((em8xxx_kmem_size - msize) >= 0x04000000UL) || ((em8xxx_kmem_size - msize) > offset))
+				return(((i - REMAP_IDX) * 0x04000000UL) + CPU_REMAP_SPACE + offset);
+			else
+				break;	/* outside kernel memory area, don't translate it */
+		}
+	}
+/*	printk("<3>" "dma_address inversion failure (0x%08lx)\n", mapaddr); */
+	return(mapaddr); /* use whatever is specified */
+}
+#endif
+
+#endif /* __HARDWARE_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango3/rmdefs.h linux-2.6.29/arch/mips/include/asm/tango3/rmdefs.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango3/rmdefs.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango3/rmdefs.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,11 @@
+
+#ifndef __RMDEFS_H
+#define __RMDEFS_H
+
+typedef unsigned long RMuint32;
+typedef unsigned short RMuint16;
+typedef unsigned char RMuint8;
+typedef char RMascii;
+typedef int RMstatus;
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3api.h linux-2.6.29/arch/mips/include/asm/tango3/tango3api.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3api.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango3/tango3api.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,118 @@
+/*
+ * include/asm-mips/tango3/tango3api.h
+ *
+ * Copyright 2002-2007, Sigma Designs, Inc 
+ *
+ * This file contains SMP86XX controling functions
+ *
+ */
+
+#ifndef __ASM_ARCH_EM86XX_H
+#define __ASM_ARCH_EM86XX_H
+#include <asm/tango3/hardware.h>
+//
+// global variables
+// 
+
+//
+// from arch/arm/arch-em86xx/irq.c
+//
+
+// irq
+void em86xx_mask_irq(unsigned int irq);
+void em86xx_unmask_irq(unsigned int irq);
+void em86xx_wait_irq(unsigned int irq);
+
+// fiq
+void em86xx_mask_fiq(unsigned int fiq);
+void em86xx_unmask_fiq(unsigned int fiq);
+
+// software interrupt
+int em86xx_softirq_isset(int irq);
+void em86xx_softirq_set(int irq);
+void em86xx_softirq_clr(int irq);
+void em86xx_irq_clr(int irq);
+
+//
+// from arch/arm/arch-em86xx/em86xxapi.c
+//
+
+// Cache
+// clean : write dirty buffer (D cache only)
+// invalidate : invalidate the contents of cache (I & D cache)
+// flush : clean + invalidate
+void em86xx_get_cache_state(int *picache, int *pdcache, int *pwriteback);
+void em86xx_enable_cache(int icache, int dcache, int writeback);
+void em86xx_clean_cache_data(void);
+void em86xx_clean_cache_data_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_instruction(void);
+void em86xx_invalidate_cache_instruction_region(unsigned int from, unsigned int to);
+void em86xx_invalidate_cache_data(void);
+void em86xx_invalidate_cache_data_region(unsigned int from, unsigned int to);
+
+void em86xx_flush_cache_all(void);
+void em86xx_flush_cache_data(void);
+void em86xx_flush_cache_data_region(unsigned int from, unsigned int to);
+
+// memory
+unsigned int em86xx_get_pciregionsize(void);
+unsigned int em86xx_get_dmamemorysize(void);
+
+// switchbox (Host interface)
+enum { 
+	SBOX_MBUS_W0 = 0, SBOX_MBUS_W1, SBOX_PCIMASTER, SBOX_PCISLAVE, 
+	SBOX_SATA0, SBOX_IDEFLASH, SBOX_IDEDVD, SBOX_SATA1, SBOX_MBUS_W2, SBOX_HOST_CIPHER, SBOX_MAX
+};
+
+int em86xx_sbox_init(void);
+#if 0
+void em86xx_sbox_reset(void);
+int em86xx_sbox_setup(void);
+int em86xx_sbox_connect(int iface);
+void em86xx_sbox_disconnect(int port);
+#endif
+
+// MBUS DMA 
+typedef void (*mbus_irq_handler_t)(int irq, void *arg);
+
+int em86xx_mbus_alloc_dma(int sbox, int fromdev, unsigned long *pregbase, int *pirq, int canwait);
+void em86xx_mbus_free_dma(unsigned long regbase, int sbox);
+int em86xx_mbus_setup_dma(unsigned int regbase, unsigned int addr, unsigned int count, mbus_irq_handler_t handler, void *arg, unsigned int flags);
+int em86xx_mbus_notification(unsigned int regbase, mbus_irq_handler_t handler, void *arg);
+int em86xx_mbus_inuse(unsigned int regbase);
+int em86xx_mbus_wait(unsigned int regbase, int sbox);
+void em86xx_mbus_reset(unsigned int regbase, int sbox);
+int mbus_memcpy(unsigned int regbase, unsigned int src, unsigned int dst, unsigned int size);
+
+// PCI master
+void em86xx_pcimaster_setup_read(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_read(int start);
+void em86xx_pcimaster_setup_write(unsigned int addr, unsigned int count);
+void em86xx_pcimaster_start_write(int start);
+
+// GPIO
+#define GPIO_INPUT		0
+#define GPIO_OUTPUT		1
+
+int em86xx_gpio_read(int gpio);
+void em86xx_gpio_write(int gpio, int data);
+void em86xx_gpio_setdirection(int gpio, int dir);
+
+int em86xx_gpio_getmode(int gpio);
+int em86xx_gpio_setmode(int gpio, int mode, int *oldmode);
+
+int em86xx_uart0_gpio_read(int gpio);
+void em86xx_uart0_gpio_write(int gpio, int data);
+void em86xx_uart0_gpio_setdirection(int gpio, int dir);
+int em86xx_uart1_gpio_read(int gpio);
+void em86xx_uart1_gpio_write(int gpio, int data);
+void em86xx_uart1_gpio_setdirection(int gpio, int dir);
+
+#define NUM_TANGOX_MUTEX	4
+#define MUTEX_PBI		0
+
+int tangox_mutex_lock(unsigned int idx);
+int tangox_mutex_unlock(unsigned int idx);
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3_gbus.h linux-2.6.29/arch/mips/include/asm/tango3/tango3_gbus.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3_gbus.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango3/tango3_gbus.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,39 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_GBUS_H
+#define __TANGO3_GBUS_H
+
+#ifndef __ASSEMBLY__
+
+#include "rmdefs.h"
+
+#include <asm/addrspace.h>
+
+struct gbus;
+#define pGBus ((struct gbus *)1)
+
+RMuint32 gbus_read_uint32(struct gbus *pgbus, RMuint32 byte_address);
+RMuint16 gbus_read_uint16(struct gbus *pgbus, RMuint32 byte_address);
+RMuint8 gbus_read_uint8(struct gbus *pgbus, RMuint32 byte_address);
+void gbus_write_uint32(struct gbus *pgbus, RMuint32 byte_address, RMuint32 data);
+void gbus_write_uint16(struct gbus *pgbus, RMuint32 byte_address, RMuint16 data);
+void gbus_write_uint8(struct gbus *pgbus, RMuint32 byte_address, RMuint8 data);
+
+#define gbus_read_reg32(r)      __raw_readl((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg16(r)      __raw_readw((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_read_reg8(r)       __raw_readb((volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg32(r, v)  __raw_writel(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg16(r, v)  __raw_writew(v, (volatile void __iomem *)KSEG1ADDR(r))
+#define gbus_write_reg8(r, v)   __raw_writeb(v, (volatile void __iomem *)KSEG1ADDR(r))
+
+#endif /* !__ASSEMBLY__ */
+#endif /* __TANGO3_GBUS_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3.h linux-2.6.29/arch/mips/include/asm/tango3/tango3.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango3/tango3.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,76 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   tango3.h
+  @brief  
+
+  <long description>
+
+  @author Emmanuel Michon
+  @date   2004-05-10
+*/
+
+#ifndef __TANGO3_H__
+#define __TANGO3_H__
+#include <asm/tango3/hardware.h>
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/emhwlib_lram.h>
+#include <asm/tango3/emhwlib_resources_tango3.h>
+#ifndef CONFIG_TANGOX_BASE_FREQUENCY
+#define TANGOX_BASE_FREQUENCY	27000000 
+#endif
+#define TANGO3_UART_FREQUENCY   7372800
+/* Baudrate setting */
+#if defined(CONFIG_TANGO3_SMP86XX)
+#ifndef CONFIG_TANGOX_BASE_BAUD
+#define TANGOX_BASE_BAUD 38400
+#else
+#define TANGOX_BASE_BAUD CONFIG_TANGOX_BASE_BAUD
+#endif
+//#define TANGOX_CPU_FREQUENCY 333000000
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO3_SMP86XX */
+
+/* Memory size used by Linux */
+#ifndef CONFIG_TANGOX_MEMSIZE
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define  TANGOX_SYSTEMRAM_ACTUALSIZE   (32*1024*1024)
+#else
+#error "Unsupported platform"
+#endif /* CONFIG_TANGO3_SMP86XX */
+#else
+#define TANGOX_SYSTEMRAM_ACTUALSIZE    CONFIG_TANGOX_MEMSIZE
+#endif /* !CONFIG_TANGOX_MEMSIZE */
+
+#define TANGOX_CTRLIRQ 0
+#define TANGOX_CTRLFIQ 1
+#define TANGOX_CTRLIIQ 2
+
+#if defined(CONFIG_TANGO3_SMP86XX)
+#define SYS_clkgen_pll        SYS_clkgen1_pll
+#endif
+
+#define RMCHIP_ID_SMP8644 (8644)
+#define RMCHIP_ID_SMP8642 (8642)
+#define RMCHIP_ID_SMP8646 (8646)
+
+#define RMCHIP_ID_SMP8654 (8654)
+#define RMCHIP_ID_SMP8652 (8652)
+#define RMCHIP_ID_SMP8656 (8656)
+#define RMCHIP_ID_SMP8658 (8658)
+#define RMCHIP_ID_SMP8670 (8670)
+#define RMCHIP_ID_SMP8672 (8672)
+#define RMCHIP_ID_SMP8674 (8674)
+
+#endif // __TANGO3_H__
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3_pci.h linux-2.6.29/arch/mips/include/asm/tango3/tango3_pci.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3_pci.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango3/tango3_pci.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,75 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_PCI_H
+#define __TANGO3_PCI_H
+
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+
+#define PCIEM86XX_PCIFAULT_INTR		((IRQ_CONTROLLER_IRQ_BASE) + \
+						(LOG2_CPU_PCI_FAULT_INT))
+
+#define PCIEM86XX_ARBITER_LEVEL		0x00
+#define PCIEM86XX_ARBITER_GRANTTIMEOUT	0x10101010
+
+#define PCIEM86XX_IDSEL_MAX		0x05 	/* SMP865x:4, SMP864x:5 */
+#define PCIEM86XX_IDSEL_BITS		0x03
+
+/*
+ * helpers to access host interface registers
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_read_reg32(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_read_reg8(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_write_reg8(REG_BASE_host_interface + (r), (v))
+
+
+/*
+ * read/write data  from/to the configuration space.  The  only way to
+ * know if there is a device is by checking that we did not generate a
+ * bus fault interrupt, so we need to mask them during the access.
+ */
+#define BUILD_TANGOX_CFG_ACCESS(pfx, __x)				\
+static inline int tangox_cfg_##pfx(void __iomem *addr, u32 *data)	\
+{									\
+	unsigned long flags, status;					\
+									\
+	local_irq_save(flags);						\
+									\
+	__x;								\
+	status = (RD_HOST_REG8(PCI_host_reg2 + 3) >> 1) & 0x3;		\
+	if (status) {							\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 1);			\
+		WR_HOST_REG8(PCI_host_reg2 + 3, 0);			\
+		local_irq_restore(flags);				\
+		return 1;						\
+	}								\
+									\
+	local_irq_restore(flags);					\
+	return 0;							\
+}
+
+BUILD_TANGOX_CFG_ACCESS(read8, *data = readb(addr) & 0xff)
+BUILD_TANGOX_CFG_ACCESS(read16, *data = readw(addr) & 0xffff)
+BUILD_TANGOX_CFG_ACCESS(read32, *data = readl(addr))
+BUILD_TANGOX_CFG_ACCESS(write8, writeb(*data & 0xff, addr))
+BUILD_TANGOX_CFG_ACCESS(write16, writew(*data & 0xffff, addr))
+BUILD_TANGOX_CFG_ACCESS(write32, writel(*data, addr))
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3_usb.h linux-2.6.29/arch/mips/include/asm/tango3/tango3_usb.h
--- linux-2.6.29.ref/arch/mips/include/asm/tango3/tango3_usb.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/include/asm/tango3/tango3_usb.h	2011-05-24 12:39:48.704295664 -0700
@@ -0,0 +1,39 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __TANGO3_USB_H
+#define __TANGO3_USB_H
+
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+
+#define TANGOX_EHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_EHCI_INT)
+#define TANGOX_OHCI_IRQ	(IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_USB_OHCI_INT)
+
+#define TANGOX_EHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1400)
+#define TANGOX_OHCI_BASE_ADDR		(REG_BASE_host_interface + 0x1500)
+#define TANGOX_USB_CTL_STATUS_REG_BASE	(REG_BASE_host_interface + 0x1700)
+
+/*
+ * helpers to access USB registers
+ */
+#define RD_OHCI_REG32(r)	\
+		gbus_read_reg32(TANGOX_OHCI_BASE_ADDR + (r))
+
+#define WR_OHCI_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_OHCI_BASE_ADDR + (r), (v))
+
+#define RD_USB_REG32(r)	\
+		gbus_read_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r))
+
+#define WR_USB_REG32(r, v)	\
+		gbus_write_reg32(TANGOX_USB_CTL_STATUS_REG_BASE + (r), (v))
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/Kconfig linux-2.6.29/arch/mips/Kconfig
--- linux-2.6.29.ref/arch/mips/Kconfig	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/arch/mips/Kconfig	2011-05-24 12:39:48.704295664 -0700
@@ -552,6 +552,23 @@
 	  Technology and now in turn merged with Fujitsu.  Say Y here to
 	  support this machine type.
 
+config TANGOX
+	bool "Sigma Designs TangoX chips/boards"
+	select BOOT_RAW
+	select CEVT_R4K
+#	select CSRC_R4K
+ 	select CRYPTO_SHA1
+	select DMA_NONCOHERENT
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R1
+	select SYS_HAS_CPU_MIPS32_R2
+	select OWN_DMA
+	select DMA_TANGOX
+	select ZONE_DMA
+	help
+	  Enable the support for Sigma Designs chips/boards. 
+
 config MACH_TX39XX
 	bool "Toshiba TX39 series based machines"
 
@@ -646,6 +663,7 @@
 source "arch/mips/pmc-sierra/Kconfig"
 source "arch/mips/sgi-ip27/Kconfig"
 source "arch/mips/sibyte/Kconfig"
+source "arch/mips/tangox/Kconfig"
 source "arch/mips/txx9/Kconfig"
 source "arch/mips/vr41xx/Kconfig"
 source "arch/mips/cavium-octeon/Kconfig"
@@ -764,6 +782,10 @@
 config DMA_COHERENT
 	bool
 
+config DMA_TANGOX
+	bool
+	select DMA_NEED_PCI_MAP_STATE
+
 config DMA_NONCOHERENT
 	bool
 	select DMA_NEED_PCI_MAP_STATE
@@ -984,6 +1006,8 @@
 	default "7" if SGI_IP22 || SGI_IP27 || SGI_IP28 || SNI_RM || CPU_CAVIUM_OCTEON
 	default "6" if MIPS_CPU_SCACHE
 	default "4" if PMC_MSP4200_EVAL
+	default "4" if TANGO2
+	default "5" if TANGO3 && !MIPS_CPU_SCACHE
 	default "5"
 
 config HAVE_STD_PC_SERIAL_PORT
@@ -1342,6 +1366,7 @@
 #
 config WEAK_REORDERING_BEYOND_LLSC
 	bool
+
 endmenu
 
 #
@@ -1385,7 +1410,6 @@
 menu "Kernel type"
 
 choice
-
 	prompt "Kernel code model"
 	help
 	  You should only select this option if you have a workload that
@@ -1505,6 +1529,7 @@
 	select SYS_SUPPORTS_SCHED_SMT if SMP
 	select SYS_SUPPORTS_SMP
 	select SMP_UP
+	select MIPS_CMP
 	help
 	  This is a kernel model which is also known a VSMP or lately
 	  has been marketesed into SMVP.
@@ -1521,6 +1546,7 @@
 	select SMP
 	select SYS_SUPPORTS_SMP
 	select SMP_UP
+	select MIPS_CMP
 	help
 	  This is a kernel model which is known a SMTC or lately has been
 	  marketesed into SMVP.
@@ -1542,7 +1568,6 @@
 config SYS_SUPPORTS_SCHED_SMT
 	bool
 
-
 config SYS_SUPPORTS_MULTITHREADING
 	bool
 
@@ -1612,7 +1637,7 @@
 
 config MIPS_CMP
 	bool "MIPS CMP framework support"
-	depends on SYS_SUPPORTS_MIPS_CMP
+	depends on SYS_SUPPORTS_MIPS_CMP && (MIPS_MT_SMP || MIPS_MT_SMTC)
 	select SYNC_R4K
 	select SYS_SUPPORTS_SMP
 	select SYS_SUPPORTS_SCHED_SMT if SMP
@@ -2144,3 +2169,4 @@
 source "crypto/Kconfig"
 
 source "lib/Kconfig"
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/kernel/cevt-r4k.c linux-2.6.29/arch/mips/kernel/cevt-r4k.c
--- linux-2.6.29.ref/arch/mips/kernel/cevt-r4k.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/kernel/cevt-r4k.c	2011-05-24 12:39:48.704295664 -0700
@@ -14,6 +14,29 @@
 #include <asm/time.h>
 #include <asm/cevt-r4k.h>
 
+#ifdef CONFIG_TANGOX
+#if defined(CONFIG_TANGO2)
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango3/emhwlib_lram_others.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_lram_tango3.h>
+#endif
+void reset_timer(unsigned long cpu, unsigned long sys, unsigned long pll, unsigned long premux, unsigned long mux);
+extern unsigned long tangox_get_cpuclock(void);
+extern unsigned long tangox_get_sysclock(void);
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+extern unsigned long em8xxx_sys_clkgen_pll;
+extern unsigned long em8xxx_sys_premux;
+extern unsigned long em8xxx_sys_mux;
+extern unsigned long orig_cpu_freq;
+#endif /* CONFIG_TANGOX */
+
 /*
  * The SMTC Kernel for the 34K, 1004K, et. al. replaces several
  * of these routines with SMTC-specific variants.
@@ -53,6 +76,32 @@
 	struct clock_event_device *cd;
 	int cpu = smp_processor_id();
 
+#ifdef CONFIG_TANGOX
+	static unsigned long last_jiffies = ((unsigned long)(unsigned int)(-600*HZ));
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	unsigned long clkgen_pll = gbus_read_reg32(REG_BASE_system_block + SYS_clkgen_pll);
+	unsigned long premux = gbus_read_reg32(REG_BASE_system_block + SYS_sysclk_premux) & 0x3;
+	unsigned long mux = gbus_read_reg32(REG_BASE_system_block + SYS_sysclk_mux) & 0xf01;
+#endif
+
+	if (time_after(jiffies, last_jiffies + HZ)) { 
+		last_jiffies = jiffies;
+		/* Update heart beat counter */
+		gbus_write_reg32(REG_BASE_cpu_block + LR_HB_CPU,
+				gbus_read_reg32(REG_BASE_cpu_block + LR_HB_CPU) + 1);
+#if defined(CONFIG_PRINTK_TIME)
+//		printk("*** time marker *** (0x%08x)\n", gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt));
+#endif
+	}
+
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	if ((em8xxx_sys_clkgen_pll != clkgen_pll) || (em8xxx_sys_premux != premux) || (em8xxx_sys_mux != mux)) {
+		/* Detected potential CPU/System frequency change */
+		reset_timer(tangox_get_cpuclock(), tangox_get_sysclock(), clkgen_pll, premux, mux);
+        }
+#endif
+#endif /* CONFIG_TANGOX */
+
 	/*
 	 * Suckage alert:
 	 * Before R2 of the architecture there was no way to see if a
@@ -213,3 +262,34 @@
 }
 
 #endif /* Not CONFIG_MIPS_MT_SMTC */
+
+#ifdef CONFIG_TANGOX
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+void reset_timer(unsigned long cpuf, unsigned long sysf, unsigned long pll, unsigned long premux, unsigned long mux)
+{
+	unsigned int cpu = smp_processor_id();
+	struct clock_event_device *cd;
+	unsigned long flags;
+
+	printk("Detected frequency changed ...\n");
+
+	em8xxx_sys_clkgen_pll = pll;
+	em8xxx_sys_premux = premux;
+	em8xxx_sys_mux = mux;
+        em8xxx_cpu_frequency = cpuf;
+        em8xxx_sys_frequency = sysf;
+
+	local_irq_save(flags);
+        mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+	cd = &per_cpu(mips_clockevent_device, cpu);
+	clockevents_set_mode(cd, CLOCK_EVT_MODE_SHUTDOWN);
+	cd->mult	= div_sc((unsigned long)mips_hpt_frequency, NSEC_PER_SEC, 32);
+	cd->max_delta_ns	= clockevent_delta2ns(0x7fffffff, cd);
+	cd->min_delta_ns	= clockevent_delta2ns(0x300, cd);
+	local_irq_restore(flags);
+	clockevents_set_mode(cd, CLOCK_EVT_MODE_ONESHOT);
+}
+EXPORT_SYMBOL(reset_timer);
+#endif
+#endif /* CONFIG_TANGOX */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/kernel/head.S linux-2.6.29/arch/mips/kernel/head.S
--- linux-2.6.29.ref/arch/mips/kernel/head.S	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/kernel/head.S	2011-05-24 12:39:48.704295664 -0700
@@ -131,7 +131,7 @@
 
 EXPORT(_stext)
 
-#ifdef CONFIG_BOOT_RAW
+#if defined(CONFIG_BOOT_RAW)
 	/*
 	 * Give us a fighting chance of running if execution beings at the
 	 * kernel load address.  This is needed because this platform does
@@ -141,6 +141,12 @@
 	j	kernel_entry
 #endif
 
+#if defined(CONFIG_TANGOX)
+	/* Creating some buffer for power management purpose */
+	/* Mark 16KB off the starting point */
+	.org 0x4000
+#endif
+
 	__REF
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/kernel/proc.c linux-2.6.29/arch/mips/kernel/proc.c
--- linux-2.6.29.ref/arch/mips/kernel/proc.c	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/arch/mips/kernel/proc.c	2011-05-24 12:39:48.704295664 -0700
@@ -42,9 +42,15 @@
 	seq_printf(m, fmt, __cpu_name[n],
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
+#ifdef CONFIG_TANGOX
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
 	              cpu_data[n].udelay_val / (500000/HZ),
 	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
+#else
+	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
+	              cpu_data[n].udelay_val / (500000/HZ),
+	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
+#endif
 	seq_printf(m, "wait instruction\t: %s\n", cpu_wait ? "yes" : "no");
 	seq_printf(m, "microsecond timers\t: %s\n",
 	              cpu_has_counter ? "yes" : "no");
@@ -79,6 +85,21 @@
 	seq_printf(m, fmt, 'I', vcei_count);
 	seq_printf(m, "\n");
 
+#ifdef CONFIG_TANGOX
+	{
+		extern unsigned long tangox_get_cpuclock(void);
+		extern unsigned long tangox_get_sysclock(void);
+		extern unsigned long tangox_get_dspclock(void);
+		extern unsigned long tangox_chip_id(void);
+		unsigned long chip_id = (tangox_chip_id() >> 16) & 0xffff;
+		unsigned long chip_rev = tangox_chip_id() & 0xff;
+		seq_printf(m, "SMP8XXX Chip ID\t\t: %lx\n", chip_id);
+		seq_printf(m, "SMP8XXX Rev ID\t\t: %lx\n", chip_rev);
+		seq_printf(m, "System bus frequency\t: %ld Hz\n", tangox_get_sysclock());
+		seq_printf(m, "CPU frequency\t\t: %ld Hz\n", tangox_get_cpuclock());
+		seq_printf(m, "DSP frequency\t\t: %ld Hz\n", tangox_get_dspclock());
+	}
+#endif
 	return 0;
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/kernel/setup.c linux-2.6.29/arch/mips/kernel/setup.c
--- linux-2.6.29.ref/arch/mips/kernel/setup.c	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/arch/mips/kernel/setup.c	2011-05-24 12:39:48.704295664 -0700
@@ -9,6 +9,7 @@
  * Copyright (C) 1996 Stoned Elipot
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) 2000, 2001, 2002, 2007  Maciej W. Rozycki
+ * Copyright (C) 2003-2009 Sigma Designs, Inc.
  */
 #include <linux/init.h>
 #include <linux/ioport.h>
@@ -32,6 +33,19 @@
 #include <asm/smp-ops.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/memcfg.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/hardware.h>
+#include "../tangox/xenv.h"
+#include "../tangox/xenvkeys.h"
+#endif
+
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);
@@ -68,6 +82,8 @@
 const unsigned long mips_io_port_base __read_mostly = -1;
 EXPORT_SYMBOL(mips_io_port_base);
 
+extern void * __rd_start, * __rd_end;
+
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
 
@@ -161,6 +177,11 @@
 {
 	unsigned long end;
 
+	if ((!initrd_start) && (&__rd_start != &__rd_end)) {
+		initrd_start = (unsigned long)&__rd_start;
+		initrd_end = (unsigned long)&__rd_end;
+	}
+
 	/*
 	 * Board specific code or command line parser should have
 	 * already set up initrd_start and initrd_end. In these cases
@@ -446,6 +467,10 @@
 static int __init early_parse_mem(char *p)
 {
 	unsigned long start, size;
+#ifdef CONFIG_TANGOX
+        extern unsigned long em8xxx_kmem_start;
+        extern unsigned long em8xxx_kmem_size;
+#endif
 
 	/*
 	 * If a user specifies memory size, we
@@ -460,8 +485,26 @@
 	size = memparse(p, &p);
 	if (*p == '@')
 		start = memparse(p + 1, &p);
+	else {
+#ifdef CONFIG_TANGOX
+		start = CPHYSADDR(em8xxx_kmem_start);
+#else
+		start = 0;
+#endif
+        }
 
+#ifdef CONFIG_TANGOX
+	if (start == CPHYSADDR(em8xxx_kmem_start)) {
+		void tangox_mem_setup(unsigned long size);
+		tangox_mem_setup(size);
+		add_memory_region(start, em8xxx_kmem_size, BOOT_MEM_RAM);
+	} else {
+		/* We just add this blindly as the alignment can be wrong, use it as own risk */
+		add_memory_region(start, size, BOOT_MEM_RAM);
+	}
+#else
 	add_memory_region(start, size, BOOT_MEM_RAM);
+#endif 
 	return 0;
 }
 early_param("mem", early_parse_mem);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/kernel/traps.c linux-2.6.29/arch/mips/kernel/traps.c
--- linux-2.6.29.ref/arch/mips/kernel/traps.c	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/arch/mips/kernel/traps.c	2011-05-24 12:39:48.704295664 -0700
@@ -49,6 +49,16 @@
 #include <asm/stacktrace.h>
 #include <asm/irq.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/emhwlib_registers_tango2.h>
+#include <asm/tango2/emhwlib_dram_tango2.h>
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/emhwlib_registers_tango3.h>
+#include <asm/tango3/emhwlib_dram_tango3.h>
+#include <asm/tango3/hardware.h>
+#endif
+
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
 extern asmlinkage void rollback_handle_int(void);
@@ -1502,6 +1512,15 @@
 	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
+#ifdef CONFIG_TANGOX
+#if defined(CONFIG_TANGO3)
+	ebase = KSEG0ADDR(CPU_REMAP_SPACE);
+#else
+	ebase = KSEG0ADDR(MEM_BASE_dram_controller_0 + FM_RESERVED);
+#endif
+	write_c0_ebase(ebase);
+#endif
+
 	if (cpu_has_mips_r2) {
 		unsigned int enable = 0x0000000f;
 
@@ -1554,6 +1573,10 @@
 		cp0_compare_irq = CP0_LEGACY_COMPARE_IRQ;
 		cp0_perfcount_irq = -1;
 	}
+#ifdef CONFIG_TANGO2
+	cp0_compare_irq = 7; /* hard-wired, cannot be checked by c0_intctl */
+	cp0_perfcount_irq = -1; /* no perfcount_irq */
+#endif
 
 #ifdef CONFIG_MIPS_MT_SMTC
 	}
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/kernel/vmlinux.lds.S linux-2.6.29/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.29.ref/arch/mips/kernel/vmlinux.lds.S	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/kernel/vmlinux.lds.S	2011-05-24 12:39:48.704295664 -0700
@@ -80,6 +80,14 @@
 		*(.data.init_task)
 
 		DATA_DATA
+
+		/* Align the initial ramdisk image (INITRD) on page boundaries. */
+		. = ALIGN(_PAGE_SIZE);
+		__rd_start = .;
+		*(.initrd)
+		. = ALIGN(_PAGE_SIZE);
+		__rd_end = .;
+
 		CONSTRUCTORS
 	}
 	_gp = . + 0x8000;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/Makefile linux-2.6.29/arch/mips/Makefile
--- linux-2.6.29.ref/arch/mips/Makefile	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/Makefile	2011-05-24 12:39:48.723561605 -0700
@@ -602,6 +602,133 @@
 load-$(CONFIG_CPU_CAVIUM_OCTEON) 	+= 0xffffffff81100000
 endif
 
+ifdef CONFIG_TANGO2
+#
+# Sigma Designs Tango2 boards
+#
+  include $(srctree)/arch/mips/include/asm/tango2/emhwlib_registers_tango2.inc
+  include $(srctree)/arch/mips/include/asm/tango2/emhwlib_dram_tango2.inc
+else
+  ifdef CONFIG_TANGO3
+#
+# Sigma Designs Tango3 boards
+#
+    include $(srctree)/arch/mips/include/asm/tango3/emhwlib_registers_tango3.inc
+    include $(srctree)/arch/mips/include/asm/tango3/emhwlib_dram_tango3.inc
+  endif
+endif
+
+ifdef CONFIG_TANGOX
+ifneq ($(XSDK_DEFAULT_CPU_CERTID),)
+CERT_ID=$(XSDK_DEFAULT_CPU_CERTID)
+endif
+
+ifneq ($(XSDK_DEFAULT_KEY_DOMAIN),)
+CERT_TYPE=$(XSDK_DEFAULT_KEY_DOMAIN)
+endif
+
+ifneq ($(CERT_TYPE),)
+  ifneq ($(CERT_ID),)
+    CERT_SET=y
+  endif
+endif
+
+ifneq ($(CERT_SET),y)
+  ifdef CONFIG_TANGO2
+    ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+      CERT_ID=000c
+      CERT_TYPE=8634_ES4_prod
+    else
+      CERT_ID=000b
+      CERT_TYPE=8634_ES4_dev
+    endif
+  else
+    ifdef CONFIG_TANGO3
+      # Use 0001 for encrypted image (instead of signed-only image) 
+      ifdef CONFIG_TANGO3_SMP8656SF
+        ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+          CERT_ID=000f
+          CERT_TYPE=8656_ES1_prod
+        else
+          CERT_ID=000f
+          CERT_TYPE=8656_ES1_dev
+        endif
+      else
+        ifdef CONFIG_TANGO3_SMP8656OTP
+          ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+            CERT_ID=000f
+            CERT_TYPE=8644_ES1_prod
+          else
+            CERT_ID=000f
+            CERT_TYPE=8644_ES1_dev
+          endif
+        else
+          ifdef CONFIG_TANGO3_SMP8672
+            ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+              CERT_ID=000f
+              CERT_TYPE=8644_ES1_prod
+            else
+              CERT_ID=000f
+              CERT_TYPE=8644_ES1_dev
+            endif
+          else
+            ifneq '$(filter -DWITH_PROD=1 -DWITH_FACSPROD=1, $(RMCFLAGS))' ''
+              CERT_ID=000f
+              CERT_TYPE=8644_ES1_prod
+            else
+              CERT_ID=000f
+              CERT_TYPE=8644_ES1_dev
+            endif
+          endif
+        endif
+      endif
+    endif
+  endif
+endif
+
+internal_hex = 0x$(shell printf "%x" $$(($(1))))
+
+core-$(CONFIG_TANGOX)		+= arch/mips/tangox/
+
+ifdef CONFIG_TANGO2
+  cflags-$(CONFIG_TANGO2)		+= -I$(srctree)/arch/mips/include/asm/mach-tango2
+  load-$(CONFIG_TANGO2)			:= $(call internal_hex,0x80000000+$(MEM_BASE_dram_controller_0)+$(FM_linuxmips__ftext))
+  cflags-$(CONFIG_TANGO2)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO2 -DEM86XX_REVISION=6
+  cflags-$(CONFIG_TANGO2)		+= -DRMCHIP_ID=RMCHIP_ID_SMP8634 -DRMCHIP_REVISION=6
+  cflags-$(CONFIG_TANGO2)		+= -mtune=4kc
+else
+  ifdef CONFIG_TANGO3
+    KERNEL_START_ADDRESS		:= $(CPU_remap2_address)
+    cflags-$(CONFIG_TANGO3)		+= -I$(srctree)/arch/mips/include/asm/mach-tango3
+    load-$(CONFIG_TANGO3)		:= $(call internal_hex,0x80000000+$(KERNEL_START_ADDRESS))
+    cflags-$(CONFIG_TANGO3)		+= -DEM86XX_CHIP=EM86XX_CHIPID_TANGO3 -DEM86XX_REVISION=3
+    cflags-$(CONFIG_TANGO3)		+= -DCPU_REMAP_SPACE=$(KERNEL_START_ADDRESS)UL -mtune=24kf
+    cflags-$(CONFIG_TANGO3)		+= -DRMCHIP_REVISION=3
+    cflags-$(CONFIG_TANGO3_SMP8652)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8652
+    cflags-$(CONFIG_TANGO3_SMP8654)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8654
+    cflags-$(CONFIG_TANGO3_SMP8656OTP)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8656
+    cflags-$(CONFIG_TANGO3_SMP8656SF)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8658
+    cflags-$(CONFIG_TANGO3_SMP8642)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8642
+    cflags-$(CONFIG_TANGO3_SMP8644)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8644
+    cflags-$(CONFIG_TANGO3_SMP8646)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8646
+    cflags-$(CONFIG_TANGO3_SMP8670)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8670
+    cflags-$(CONFIG_TANGO3_SMP8672)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8672
+    cflags-$(CONFIG_TANGO3_SMP8674)	+= -DRMCHIP_ID=RMCHIP_ID_SMP8674
+  endif
+endif
+endif
+
+CLEAN_FILES += arch/mips/boot/vmlinux.gz \
+		arch/mips/boot/*.bin \
+		arch/mips/boot/*.xload \
+		arch/mips/boot/*.zbf \
+		arch/mips/boot/zbimage-linux-* 
+
+# ramdisk/initrd support
+# You may need a compressed ramdisk image, named ramdisk.gz in
+# arch/mips/ramdisk
+core-$(CONFIG_EMBEDDED_RAMDISK) += arch/mips/ramdisk/
+
 cflags-y			+= -I$(srctree)/arch/mips/include/asm/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
 
@@ -694,7 +821,11 @@
 vmlinux.64: vmlinux
 	$(OBJCOPY) -O $(64bit-bfd) $(OBJCOPYFLAGS) $< $@
 
-makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1)
+ifdef CONFIG_TANGOX
+makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1) loadaddr=$(2) certtype=$(3) certid=$(4)
+else
+makeboot =$(Q)$(MAKE) $(build)=arch/mips/boot VMLINUX=$(vmlinux-32) $(1) 
+endif
 
 all:	$(all-y)
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/mm/cache.c linux-2.6.29/arch/mips/mm/cache.c
--- linux-2.6.29.ref/arch/mips/mm/cache.c	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/arch/mips/mm/cache.c	2011-05-24 12:39:48.723561605 -0700
@@ -30,6 +30,7 @@
 void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page,
 	unsigned long pfn);
 void (*flush_icache_range)(unsigned long start, unsigned long end);
+void (*flush_icache_page)(struct vm_area_struct *vma, struct page *page);
 void (*local_flush_icache_range)(unsigned long start, unsigned long end);
 
 void (*__flush_cache_vmap)(void);
@@ -52,6 +53,8 @@
 void (*_dma_cache_inv)(unsigned long start, unsigned long size);
 
 EXPORT_SYMBOL(_dma_cache_wback_inv);
+EXPORT_SYMBOL(_dma_cache_wback);
+EXPORT_SYMBOL(_dma_cache_inv);
 
 #endif /* CONFIG_DMA_NONCOHERENT */
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/mm/c-r4k.c linux-2.6.29/arch/mips/mm/c-r4k.c
--- linux-2.6.29.ref/arch/mips/mm/c-r4k.c	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/arch/mips/mm/c-r4k.c	2011-05-24 12:39:48.723561605 -0700
@@ -524,6 +524,12 @@
 	r4k_on_each_cpu(local_r4k_flush_cache_page, &args, 1);
 }
 
+static void r4k_flush_icache_range(unsigned long start, unsigned long end);
+static void r4k_flush_icache_page(struct vm_area_struct *vma, struct page *page)
+{
+	r4k_flush_icache_range((unsigned long)page_address(page), (unsigned long)page_address(page) + PAGE_SIZE);
+}
+
 static inline void local_r4k_flush_data_cache_page(void * addr)
 {
 	r4k_blast_dcache_page((unsigned long) addr);
@@ -1402,6 +1408,7 @@
 	flush_data_cache_page	= r4k_flush_data_cache_page;
 	flush_icache_range	= r4k_flush_icache_range;
 	local_flush_icache_range	= local_r4k_flush_icache_range;
+	flush_icache_page       = r4k_flush_icache_page;
 
 #if defined(CONFIG_DMA_NONCOHERENT)
 	if (coherentio) {
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/mm/init.c linux-2.6.29/arch/mips/mm/init.c
--- linux-2.6.29.ref/arch/mips/mm/init.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/arch/mips/mm/init.c	2011-05-24 12:39:48.723561605 -0700
@@ -40,6 +40,12 @@
 #include <asm/tlb.h>
 #include <asm/fixmap.h>
 
+#if defined(CONFIG_TANGO2)
+#include <asm/tango2/hardware.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#endif
+
 /* Atomicity and interruptability */
 #ifdef CONFIG_MIPS_MT_SMTC
 
@@ -321,6 +327,12 @@
 	unsigned long max_zone_pfns[MAX_NR_ZONES];
 	unsigned long lastpfn;
 
+#if defined(CONFIG_TANGOX) && defined(CONFIG_PCI)
+	extern unsigned long em8xxx_kmem_start;
+	extern unsigned long em8xxx_kmem_size;
+	extern int tangox_pci_host_enabled(void);
+#endif
+
 	pagetable_init();
 
 #ifdef CONFIG_HIGHMEM
@@ -329,7 +341,13 @@
 	kmap_coherent_init();
 
 #ifdef CONFIG_ZONE_DMA
-	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
+#if defined(CONFIG_TANGOX) && defined(CONFIG_PCI)
+	/* If PCI is used, then limit DMA memory to MAX_PCIMEM_MAP_SIZE if kernel memory is > MAX_PCIMEM_MAP_SIZE */
+	if (tangox_pci_host_enabled() && (em8xxx_kmem_size>(MAX_PCIMEM_MAP_SIZE<<20)))
+		max_zone_pfns[ZONE_DMA] = PFN_DOWN(virt_to_phys((void *)((em8xxx_kmem_start+(MAX_PCIMEM_MAP_SIZE<<20))&0xfff00000)));
+	else
+#endif
+		max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
 #endif
 #ifdef CONFIG_ZONE_DMA32
 	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/ramdisk/ld.script linux-2.6.29/arch/mips/ramdisk/ld.script
--- linux-2.6.29.ref/arch/mips/ramdisk/ld.script	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/ramdisk/ld.script	2011-05-24 12:39:48.723561605 -0700
@@ -0,0 +1,9 @@
+OUTPUT_ARCH(mips)
+SECTIONS
+{
+  .initrd :
+  {
+       *(.data)
+  }
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/ramdisk/Makefile linux-2.6.29/arch/mips/ramdisk/Makefile
--- linux-2.6.29.ref/arch/mips/ramdisk/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/ramdisk/Makefile	2011-05-24 12:39:48.723561605 -0700
@@ -0,0 +1,23 @@
+#
+# Makefile for a ramdisk image
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+ifneq ($(CONFIG_EMBEDDED_RAMDISK),)
+ifneq ($(CONFIG_EMBEDDED_RAMDISK_IMAGE),)
+IMAGENAME := $(CONFIG_EMBEDDED_RAMDISK_IMAGE)
+else
+IMAGENAME := $(SMP86XX_ROOTFS_PATH)/root_fs_mipsel.cramfs
+endif
+RDPATH := $(TOPDIR)/arch/mips/ramdisk
+O_FORMAT := $(shell $(OBJDUMP) -i | head -2 | grep elf32)
+RD_MADE := $(shell $(LD) $(LDFLAGS) -T $(RDPATH)/ld.script -b binary --oformat $(O_FORMAT) -o $(RDPATH)/ramdisk.o $(IMAGENAME))
+endif
+
+obj-$(CONFIG_EMBEDDED_RAMDISK) += ramdisk.o
+
+clean-files += ramdisk.o
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/console.c linux-2.6.29/arch/mips/tangox/console.c
--- linux-2.6.29.ref/arch/mips/tangox/console.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/console.c	2011-05-24 12:42:54.574039934 -0700
@@ -0,0 +1,151 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * simple  uart support for  tango2/tango3 board,  register an  early console
+ * that make boot problem easier to debug.
+ *
+ * this uart init code comes from zboot
+ */
+
+#include <linux/init.h>
+#include <linux/console.h>
+
+#include "setup.h"
+
+extern int tangox_uart_baudrate(int uart);
+extern int tangox_uart_console_port(void);
+extern unsigned long tangox_chip_id(void);
+
+#if defined(CONFIG_TANGO3) 
+/*
+ * helpers to access uart0/uart1/uart2 register
+ */
+#define RD_UART_REG32(r)							\
+	((tangox_uart_console_port() == 0) ? 					\
+		gbus_read_reg32((((((tangox_chip_id() >> 16) & 0xfffe) == 0x8656) || (((tangox_chip_id() >> 16) & 0xfffe) == 0x8672)) ? \
+				(REG_BASE_system_block + 0x700) : (REG_BASE_cpu_block + CPU_UART0_base)) + (r)) : \
+		((tangox_uart_console_port() == 1) ? 				\
+			gbus_read_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r)) : 	\
+			gbus_read_reg32(REG_BASE_cpu_block + CPU_UART2_base + (r))))
+
+#define WR_UART_REG32(r, v)								\
+	((tangox_uart_console_port() == 0) ? 						\
+		gbus_write_reg32((((((tangox_chip_id() >> 16) & 0xfffe) == 0x8656) || (((tangox_chip_id() >> 16) & 0xfffe) == 0x8672)) ? \
+				(REG_BASE_system_block + 0x700) : (REG_BASE_cpu_block + CPU_UART0_base)) + (r), (v)) : \
+		((tangox_uart_console_port() == 1) ? 					\
+			gbus_write_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r), (v)) : 	\
+			gbus_write_reg32(REG_BASE_cpu_block + CPU_UART2_base + (r), (v)))) 
+#else
+/*
+ * helpers to access uart0/uart1 register
+ */
+#define RD_UART_REG32(r)							\
+	((tangox_uart_console_port() == 0) ? 					\
+		gbus_read_reg32(REG_BASE_cpu_block + CPU_UART0_base + (r)) :	\
+		gbus_read_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r)))
+
+#define WR_UART_REG32(r, v)								\
+	((tangox_uart_console_port() == 0) ? 						\
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + (r), (v)) :	\
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_UART1_base + (r), (v)))
+#endif
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+/*
+ * print given char to uart0/uart1/uart2
+ */
+static void __init prom_putc(char c)
+{
+	/* if '\n', then print '\r' also */
+	if (c == '\n') {
+		prom_putc('\r');
+	}
+
+	while ((RD_UART_REG32(CPU_UART_LSR) & 0x20) == 0);
+	WR_UART_REG32(CPU_UART_THR, (unsigned long)c);
+	while ((RD_UART_REG32(CPU_UART_LSR) & 0x20) == 0);
+}
+
+/*
+ * print given string to uart0/uart1/uart2
+ */
+void __init prom_puts(const char *s)
+{
+	while (*s)
+		prom_putc(*s++);
+}
+#endif
+
+/*
+ * initialize uart0/uart1/uart2 with given parameters
+ */
+void __init uart_init(int baud, int fifo)
+{
+	unsigned int div;
+
+	WR_UART_REG32(CPU_UART_IER, 0x0);
+	WR_UART_REG32(CPU_UART_FCR, (fifo ? 0x1f : 0x0));
+	WR_UART_REG32(CPU_UART_LCR, 0x3);
+
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	WR_UART_REG32(CPU_UART_CLKSEL, 0x0);
+	div = (tangox_get_sysclock() / baud) >> 4;
+	if (((((tangox_get_sysclock() * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+	WR_UART_REG32(CPU_UART_CLKDIV, div);
+#else
+	WR_UART_REG32(CPU_UART_CLKSEL, 0x1);
+#ifdef CONFIG_TANGO2
+	div = (TANGOX_BASE_FREQUENCY / baud) >> 4;
+	if (((((TANGOX_BASE_FREQUENCY * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+#elif defined(CONFIG_TANGO3)
+	div = (TANGO3_UART_FREQUENCY / baud) >> 4;
+	if (((((TANGO3_UART_FREQUENCY * 10) / baud) >> 4) % 10) >= 5)
+		div++;
+#else
+#error Unsupported platform.
+#endif
+	WR_UART_REG32(CPU_UART_CLKDIV, div);
+#endif
+}
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+/*
+ * kernel console write callback
+ */
+static void __init prom_console_write(struct console *con, const char *s,
+				      unsigned int c)
+{
+	prom_puts(s);
+}
+
+static struct console promcons __initdata = {
+	.name   = "prom",
+	.write  = prom_console_write,
+	.flags  = CON_PRINTBUFFER | CON_BOOT,
+	.index  = -1,
+};
+
+/*
+ * init uart0/uart1/uart2 and register a console that will use our prom console
+ * callbacks
+ */
+void __init prom_console_register(void)
+{
+	uart_init(tangox_uart_baudrate(tangox_uart_console_port()), 0);
+	register_console(&promcons);
+
+	/* hello world ! */
+	printk(KERN_INFO "prom console registered\n");
+}
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/cpucache.c linux-2.6.29/arch/mips/tangox/cpucache.c
--- linux-2.6.29.ref/arch/mips/tangox/cpucache.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/cpucache.c	2011-05-24 12:39:48.723561605 -0700
@@ -0,0 +1,113 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file  cpucache.c
+  @brief  
+
+  Implementing /proc/cpucache_info interface
+
+  @author YH Lin
+  @date   2006-08-16
+*/
+
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/tango2_gbus.h>
+#else
+#error Only Tango2 is supported ...
+#endif
+
+static int cpucache_info_read_proc(char *buf, char **start, off_t off, int count, int *eof, void *data);
+static unsigned long cpucache_saved_jiffies = 0;
+static unsigned icache_missed = 0, dcache_missed = 0;
+
+extern unsigned long em8xxx_cpu_frequency;
+
+//
+// init
+//
+int __init cpucache_info_init(void)
+{
+	create_proc_read_entry("cpucache_info", S_IRUGO, NULL, cpucache_info_read_proc, NULL);
+
+        printk("Created /proc/cpucache_info entry.\n");
+
+	/* Enable performance monitor and start counting */
+	/* 0: DCache Hit 
+	 * 1: DCache Miss
+	 * 2: TLB Hit
+	 * 3: TLB Miss
+	 * 4: ICache Hit
+	 * 5: ICache Miss
+	 * 6: Instn Complete
+	 * 7: ITLB Hit
+	 * 8: ITLB Miss
+	 * 9: JTLB Hit
+	 * 10: JTLB Miss
+	 * 11: WTB Merge */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_pm_select_1, (1<<5));
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_pm_select_0, (1<<1));
+	cpucache_saved_jiffies = jiffies;
+	icache_missed = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_1);
+	dcache_missed = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_0);
+	return 0;
+}
+
+__initcall(cpucache_info_init);
+
+static int cpucache_info_read_proc(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+        int len = 0;
+	unsigned long diffj, diffi, diffd, icache_miss, dcache_miss, tmpj;
+	unsigned long pd, pi;
+        
+	icache_miss = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_1);
+	dcache_miss = gbus_read_reg32(REG_BASE_cpu_block + CPU_pm_counter_0);
+	tmpj = jiffies;
+	diffj = tmpj - cpucache_saved_jiffies; 
+	cpucache_saved_jiffies = tmpj;
+	if (diffj == 0)
+		diffj = 1;
+
+	if (icache_miss < icache_missed)
+		diffi = (0xffffffff - icache_missed) + icache_miss;
+	else
+		diffi = icache_miss - icache_missed;
+	icache_missed = icache_miss;
+
+	if (dcache_miss < dcache_missed)
+		diffd = (0xffffffff - dcache_missed) + dcache_miss;
+	else
+		diffd = dcache_miss - dcache_missed;
+	dcache_missed = dcache_miss;
+
+	len += sprintf(page+off+len, "jiffies");
+	/* The average miss per jiffies is (diffx / diffj), per second is then ((diffx * HZ) / diffj).
+	 * Assuming one instruction per clock, we have (((diffx * HZ) / diffj) / em8xxx_cpu_frequency)
+	 * as average ratio of cache miss per instruction at given period of time (from last 
+	 * measured, as expressed as (diffj / HZ)). */
+	pi = ((diffi * HZ) / diffj) / (em8xxx_cpu_frequency / 10000); /* Times 10000 to get percentage */
+	pd = ((diffd * HZ) / diffj) / (em8xxx_cpu_frequency / 10000);
+
+	len += sprintf(page+off+len, "(%ld): I-Cache miss ratio(%ld): %ld.%02ld%c, D-Cache miss ratio(%ld): %ld.%02ld%c\n",
+			diffj, diffi, pi / 100, pi % 100, '%', diffd, pd / 100, pd % 100, '%');
+	*eof = 1;
+
+        return(len);
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/delay.c linux-2.6.29/arch/mips/tangox/delay.c
--- linux-2.6.29.ref/arch/mips/tangox/delay.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/delay.c	2011-05-24 12:39:48.723561605 -0700
@@ -0,0 +1,218 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * arch/mips/tangox/delay.c
+ *
+ * Copyright (C) 2003-2009 Sigma Designs, Inc
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+
+#include "setup.h"
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)	\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_cpu_block + (r), (v))
+
+#define MAX_POLL_TIME		(25)	/* less than this we use busy polling */
+
+typedef int (*COND_FUNC_PTR)(void *);
+
+static unsigned long timer_status = 0;
+
+/* given micro seoncds, rerurn corresponding cp0 timer cout */
+static inline unsigned long tangox_get_c0_timecount(unsigned usec)
+{
+	extern unsigned long em8xxx_cpu_frequency;
+	unsigned long cnt = em8xxx_cpu_frequency / (1000000 * 2);
+	if ((cnt * (1000000 * 2)) < em8xxx_cpu_frequency)
+		cnt++; /* take the ceiling */
+	return (usec * cnt);
+}
+
+/* check if given timestamp is in the time range of [start, end) */
+static inline int tangox_time_in_range(unsigned long start, unsigned long end, unsigned long timestamp)
+{
+	return (end > start) ? ((timestamp < end) && (timestamp >= start)) : ((timestamp < end) || (timestamp >= start));
+}
+
+/* wait until we are outside the time range [start, end), or condition is false */
+static inline int tangox_wait_until(unsigned long start, unsigned long end, COND_FUNC_PTR func_ptr, void *arg)
+{
+	unsigned long timestamp;
+
+	/* wait until it's out of range, or condition evaluation is false */
+	for (timestamp = read_c0_count(); tangox_time_in_range(start, end, timestamp); timestamp = read_c0_count()) {
+		if ((func_ptr != NULL) && (((*func_ptr)(arg)) == 0))
+			return 0;
+	}
+	return (func_ptr != NULL) ? (*func_ptr)(arg) : 1; /* time's up and condition may be still true */
+}
+
+/* cp0_timer is used for system timer, and timer0 is free to be used here */
+/*
+ * CPU_time0_load
+ *  clock / HZ / (2 * prescale)
+ * CPU_time0_ctrl
+ *  PS(D2-3) : prescale. 0x00 = 1, 0x01 = 16, 0x10 = 256
+ *    There is a bug, and the actual prescale is 0x01 = 32, 0x10 = 512
+ *  M(D6) : periodic mode
+ *  E(D7) : enable
+ */
+#define TIMER_ENABLE            0x80    // D7
+#define TIMER_PERIODIC          0x40    // D6
+#define TIMER_PRESCALE_1        0x00    // D[2-3] = 00b
+#define TIMER_PRESCALE_32       0x04    // D[2-3] = 01b
+#define TIMER_PRESCALE_512      0x08    // D[2-3] = 10b
+
+static const unsigned timer_prescale_bit[3] = { 0, 5, 9 };
+static const unsigned timer_prescale[3] = { TIMER_PRESCALE_1, TIMER_PRESCALE_32, TIMER_PRESCALE_512 };
+
+static DECLARE_WAIT_QUEUE_HEAD(timer0_wq);
+static int timer0_expired = 0, timer0_init = 0;
+static spinlock_t timer0_lock;		/* Spin lock */
+static unsigned int timer0_val = 0, timer0_idx = 0;
+
+static irqreturn_t timer0_isr(int irq, void *dev_id)
+{
+	wait_queue_head_t *q = (wait_queue_head_t *)dev_id;
+	unsigned long flags;
+
+	if (q != &timer0_wq)		/* Paranoid check */
+		return IRQ_NONE;
+
+	spin_lock_irqsave(&timer0_lock, flags);
+	WR_CPU_REG32(CPU_time0_ctrl, 0); /* disable timer */
+	WR_CPU_REG32(CPU_time0_clr, 1);
+	timer0_expired = 1;
+	wake_up_interruptible(&timer0_wq);
+
+	spin_unlock_irqrestore(&timer0_lock, flags);
+	return IRQ_HANDLED;
+}
+
+/*
+ * udelay with timer0 implementation if possible
+ */
+int tangox_udelay_with_condition(unsigned int usecond, COND_FUNC_PTR func_ptr, void *arg)
+{
+	unsigned long start = read_c0_count();
+	unsigned long end = start + tangox_get_c0_timecount(usecond);
+	unsigned long flags, tmp;
+
+	if (unlikely(usecond == 0))
+		return 1;
+	else if ((func_ptr == NULL) || (usecond < MAX_POLL_TIME))
+		goto poll;	/* no condition or too short */
+	else if (in_atomic() || in_interrupt() || ((current != NULL) && signal_pending(current)))
+		goto poll;	/* not safe for context switching */
+	else if (unlikely(timer0_init == 0)) 
+		goto poll;
+	else if (test_and_set_bit(0, &timer_status) != 0)
+		goto poll;
+
+	while (usecond >= MAX_POLL_TIME) { 
+		if ((func_ptr != NULL) && (((*func_ptr)(arg)) == 0)) { /* evaluate condition first */
+			clear_bit(0, &timer_status);
+			return 0;
+		}
+		if (!tangox_time_in_range(start, end, read_c0_count())) {
+			clear_bit(0, &timer_status);
+			return (func_ptr != NULL) ? (*func_ptr)(arg) : 1; /* time's up and condition may be still true */
+		}
+
+		/* CPU_time0_value register contains just 16-bits value so
+		   take care not to let the value to overflow */
+		for (timer0_idx = 0; timer0_idx < 3; timer0_idx++) {
+			tmp = (MAX_POLL_TIME * (em8xxx_sys_frequency / 1000)) / 1000; /* MAX_POLL_TIME needs to be <= 10000 */
+			timer0_val = tmp >> timer_prescale_bit[timer0_idx];
+			if (tmp & ((1 << timer_prescale_bit[timer0_idx]) - 1))
+				timer0_val++;
+			if ((timer0_val & 0xffff0000) == 0)
+				break;
+		}
+		if (timer0_idx >= 3)	/* no prescaling factor can be found */
+			break;
+
+		spin_lock_irqsave(&timer0_lock, flags);
+		timer0_expired = 0;
+		WR_CPU_REG32(CPU_time0_load, timer0_val);
+		WR_CPU_REG32(CPU_time0_ctrl, TIMER_ENABLE | TIMER_PERIODIC | timer_prescale[timer0_idx]);
+		spin_unlock_irqrestore(&timer0_lock, flags);
+
+		/* sleep in the wait queue until timer expired, or timeout */
+		if (wait_event_interruptible(timer0_wq, timer0_expired != 0)) {
+			/* received signal -- switch to busy polling then */
+			spin_lock_irqsave(&timer0_lock, flags);
+			WR_CPU_REG32(CPU_time0_ctrl, 0); /* disable timer */
+			WR_CPU_REG32(CPU_time0_clr, 1);
+			spin_unlock_irqrestore(&timer0_lock, flags);
+			break;
+		}
+		usecond -= MAX_POLL_TIME;
+	}
+	clear_bit(0, &timer_status);
+
+poll:
+	return tangox_wait_until(start, end, func_ptr, arg);
+}
+
+int __init tangox_timer0_init(void)
+{
+	unsigned int tmp;
+
+	WR_CPU_REG32(CPU_time0_ctrl, 0); /* disable timer to begin with */
+	WR_CPU_REG32(CPU_time0_clr, 1);
+	spin_lock_init(&timer0_lock);
+
+	if (request_irq(LOG2_CPU_TIMER0_INT + IRQ_CONTROLLER_IRQ_BASE, timer0_isr, IRQF_DISABLED, "timer0", 
+			&timer0_wq) != 0) {
+		printk(KERN_ERR "timer0: cannot register IRQ (%d)\n", LOG2_CPU_TIMER0_INT + IRQ_CONTROLLER_IRQ_BASE);
+		return -EIO;
+	}
+
+	/* CPU_time0_value register contains just 16-bits value So
+	   take care not to let the value to overflow */
+	for (timer0_idx = 0; timer0_idx < 3; timer0_idx++) {
+		tmp = (MAX_POLL_TIME * (em8xxx_sys_frequency / 1000)) / 1000; /* MAX_POLL_TIME needs to be <= 10000 */
+		timer0_val = tmp >> timer_prescale_bit[timer0_idx];
+		if ((timer0_val & 0xffff0000) == 0) {
+			if (tmp & ((1 << timer_prescale_bit[timer0_idx]) - 1))
+				timer0_val++;
+			break;
+		}
+	}
+	timer0_init = 1;
+	printk(KERN_INFO "timer0: interrupt registered.\n");
+	return 0;
+}
+
+__initcall(tangox_timer0_init);
+
+void tangox_udelay(unsigned int usec)
+{
+	tangox_udelay_with_condition(usec, NULL, NULL);
+}
+
+EXPORT_SYMBOL(tangox_udelay);
+EXPORT_SYMBOL(tangox_udelay_with_condition);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/gbus.c linux-2.6.29/arch/mips/tangox/gbus.c
--- linux-2.6.29.ref/arch/mips/tangox/gbus.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/gbus.c	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,261 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * export gbus symbol to modules
+ */
+
+#include <linux/module.h>
+#include <asm/system.h>
+
+#include "setup.h"
+
+#define TMP_REMAPPED_REG	CPU_remap1
+#define TMP_REMAPPED_BASE	CPU_remap1_address
+#define TMP_REMAPPED_SIZE	0x00010000
+#define TMP_REMAPPED_MASK	~(TMP_REMAPPED_SIZE-1)
+
+#define TMP_REMAPPED_REG1	CPU_remap
+#define TMP_REMAPPED_BASE1	CPU_remap_address
+#define TMP_REMAPPED_SIZE1	0x00010000
+#define TMP_REMAPPED_MASK1	~(TMP_REMAPPED_SIZE1-1)
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+unsigned long em86xx_tlb_dram1_map_base;
+unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+static DEFINE_SPINLOCK(remap_lock);
+
+static RMuint32 set_remap(RMuint32 remap_reg, RMuint32 value)
+{
+	RMuint32 orig = *((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg));
+	if (orig != value) {
+		*((volatile RMuint32 *)KSEG1ADDR(REG_BASE_cpu_block + remap_reg)) = value;
+		iob();
+	}
+	return(orig);
+}
+
+#if defined(CONFIG_TANGO3)
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < CPU_remap2_address) {							\
+		tmp = *((volatile RMuint##size *)KSEG1ADDR(byte_address)); 				\
+		rmb();											\
+	} else {											\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			rmb();										\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			rmb();										\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+	return(tmp);											\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	mb();												\
+	if (byte_address < CPU_remap2_address) {							\
+		*((volatile RMuint##size *)KSEG1ADDR(byte_address)) = data;				\
+		iob();											\
+	} else {											\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			iob();										\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			iob();										\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+}
+
+#elif defined(CONFIG_TANGO2)
+
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))		\
+			return gbus_read_dram_uint##size(pgbus, byte_address);				\
+		else {											\
+			printk("accessing non-existed DRAM1 area 0x%08lx\n", byte_address);		\
+			return(0);									\
+		}											\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		return(tmp);										\
+	}												\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		if (byte_address < (MEM_BASE_dram_controller_1 + em86xx_tlb_dram1_map_size))		\
+			gbus_write_dram_uint##size(pgbus, byte_address, data);				\
+		else 											\
+			printk("accessing non-existed DRAM1 area 0x%08lx.\n", byte_address);		\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+	__sync();											\
+}
+
+#else /* CONFIG_TANGOX_USE_TLB_REMAP_DRAM1 */
+
+#define BUILD_GBUS_READ_OP(size)									\
+RMuint##size gbus_read_uint##size(struct gbus *pgbus, RMuint32 byte_address) 				\
+{													\
+	RMuint32 remap;											\
+	RMuint##size tmp;										\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		return gbus_read_dram_uint##size(pgbus, byte_address);					\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+								(byte_address & (TMP_REMAPPED_SIZE-1))));	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			tmp = *((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 		\
+								(byte_address & (TMP_REMAPPED_SIZE1-1))));	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		return(tmp);										\
+	}												\
+}
+
+#define BUILD_GBUS_WRITE_OP(size)									\
+void gbus_write_uint##size(struct gbus *pgbus, RMuint32 byte_address, RMuint##size data)		\
+{													\
+	RMuint32 remap;											\
+	if (byte_address < (MEM_BASE_dram_controller_0 + 0x10000000))					\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else if (byte_address < (MEM_BASE_dram_controller_1 + 0x10000000))				\
+		gbus_write_dram_uint##size(pgbus, byte_address, data);					\
+	else {												\
+		unsigned long flags;									\
+		spin_lock_irqsave(&remap_lock, flags); /* Ensure remap won't be changed */		\
+		/* Use CPU_remapx to temporarily map the address */					\
+		if (likely(byte_address != (REG_BASE_cpu_block + TMP_REMAPPED_REG))) {			\
+			remap = set_remap(TMP_REMAPPED_REG, byte_address & TMP_REMAPPED_MASK);		\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE + 			\
+							(byte_address & (TMP_REMAPPED_SIZE-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG, remap & TMP_REMAPPED_MASK);				\
+		} else {										\
+			remap = set_remap(TMP_REMAPPED_REG1, byte_address & TMP_REMAPPED_MASK1);	\
+			*((volatile RMuint##size *)KSEG1ADDR(TMP_REMAPPED_BASE1 + 			\
+							(byte_address & (TMP_REMAPPED_SIZE1-1)))) = data;	\
+			set_remap(TMP_REMAPPED_REG1, remap & TMP_REMAPPED_MASK1);			\
+		}											\
+		spin_unlock_irqrestore(&remap_lock, flags); /* Ensure remap won't be changed */		\
+	}												\
+	__sync();											\
+}
+
+#endif /* CONFIG_TANGOX_USE_TLB_REMAP_DRAM1 */
+
+#else
+#error Unsupported platform.
+#endif /* CONFIG_TANGO3 */
+
+BUILD_GBUS_READ_OP(32);
+BUILD_GBUS_READ_OP(16);
+BUILD_GBUS_READ_OP(8);
+
+BUILD_GBUS_WRITE_OP(32);
+BUILD_GBUS_WRITE_OP(16);
+BUILD_GBUS_WRITE_OP(8);
+
+EXPORT_SYMBOL(gbus_read_uint32);
+EXPORT_SYMBOL(gbus_write_uint32);
+EXPORT_SYMBOL(gbus_read_uint16);
+EXPORT_SYMBOL(gbus_write_uint16);
+EXPORT_SYMBOL(gbus_read_uint8);
+EXPORT_SYMBOL(gbus_write_uint8);
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_base);
+EXPORT_SYMBOL(em86xx_tlb_dram1_map_size);
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/irq.c linux-2.6.29/arch/mips/tangox/irq.c
--- linux-2.6.29.ref/arch/mips/tangox/irq.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/irq.c	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,470 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright (C) 2009 Sigma Designs, Inc.
+ *
+ * arch_init_irq for tango2/tango3
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/irq_cpu.h>
+
+#include "setup.h"
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)		\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		do {								\
+			gbus_write_reg32(REG_BASE_cpu_block + (r), (v));	\
+			iob();							\
+		} while(0)	
+
+#if defined(CONFIG_TANGO3)
+extern int (*perf_irq)(void);		// defined in kernel/time.c, used in oprofile
+#endif
+
+static DEFINE_SPINLOCK(mips_irq_lock);
+static DEFINE_SPINLOCK(mips_fiq_lock);
+static DEFINE_SPINLOCK(mips_iiq_lock);
+
+static inline u64 get_irq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_irq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_irq_status));
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+	return status;
+}
+
+static inline u64 get_fiq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_fiq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_fiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_fiq_status));
+	spin_unlock_irqrestore(&mips_fiq_lock, flags);
+	return status;
+}
+
+static inline u64 get_iiq_status(void)
+{
+	u64 status;
+	unsigned long flags;
+	spin_lock_irqsave(&mips_iiq_lock, flags);
+	status = (((u64)RD_CPU_REG32(CPU_iiq_status_hi))<<32) | ((u64)RD_CPU_REG32(CPU_iiq_status));
+	spin_unlock_irqrestore(&mips_iiq_lock, flags);
+	return status;
+}
+ 
+static inline int clz(unsigned long x)
+{
+	__asm__ (
+	"	.set	push					\n"
+	"	.set	mips32					\n"
+	"	clz	%0, %1					\n"
+	"	.set	pop					\n"
+	: "=r" (x)
+	: "r" (x));
+
+	return x;
+}
+
+static inline int clz64(u64 x)
+{
+	u32 xl = (u32)(x & 0xffffffff), xh = (u32)((x >> 32) & 0xffffffff);
+	return xh ? clz(xh) : clz(xl) + 32;
+}
+
+static inline unsigned int irq_ffs(unsigned int pending)
+{
+	return -clz(pending) + 31 - CAUSEB_IP;
+}
+
+extern int cp0_compare_irq;
+extern int cp0_perfcount_irq;
+
+static unsigned long edge_trig = 0;
+static unsigned long edge_trig_hi = 0;
+
+/*
+ * dispatch routine called from genex.S
+ */
+extern void spurious_interrupt(void);
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = (read_c0_cause() & read_c0_status()) & ST0_IM;
+	int irq;
+	u64 status;
+
+	if (pending == 0) {
+		printk("spurious hwirq: nothing pending\n");
+		goto spurious;
+	} else {
+		irq = irq_ffs(pending);
+
+		switch(irq) {
+			case 2: if ((status = get_irq_status()) == 0) {
+					printk("spurious irq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					do_IRQ(IRQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+				}
+				break;
+
+			case 3: if ((status = get_fiq_status()) == 0) {
+					printk("spurious fiq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					/* We need to mask out irq, fiq > irq */
+					u32 sr_old = read_c0_status();
+					u32 sr_new = sr_old & (~STATUSF_IP2);
+
+					write_c0_status(sr_new);
+					do_IRQ(FIQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+					write_c0_status(sr_old);
+				}
+				break;
+
+			case 4: if ((status = get_iiq_status()) == 0) {
+					printk("spurious iiq: 0x%llx\n", status);
+					goto spurious;
+				} else {
+					/* We need to mask out fiq/irq, iiq > fiq > irq */
+					u32 sr_old = read_c0_status();
+					u32 sr_new = sr_old & (~(STATUSF_IP2|STATUSF_IP3));
+
+					write_c0_status(sr_new);
+					do_IRQ(IIQ_CONTROLLER_IRQ_BASE + (63 - clz64(status)));
+					write_c0_status(sr_old);
+				}
+				break;
+
+			default: if ((irq == cp0_compare_irq)
+#if defined(CONFIG_TANGO3)
+					|| (irq == cp0_perfcount_irq)
+#endif
+				) {
+					do_IRQ(irq);
+				} else { 
+					printk("spurious hwirq: %d\n", irq);
+					goto spurious;
+				}
+				break;
+		}
+	}
+	return;
+
+spurious:
+	spurious_interrupt();
+	return;
+}
+
+/*
+ * our hw_irq_controller cb
+ */
+static inline void tangox_irq_enable(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_irq_enableset_hi, 1 << (bit - 32));
+	else 
+		WR_CPU_REG32(CPU_irq_enableset, 1 << bit);
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+}
+
+static inline void tangox_fiq_enable(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_fiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_fiq_enableset_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_fiq_enableset, 1 << bit);
+	spin_unlock_irqrestore(&mips_fiq_lock, flags);
+}
+
+static inline void tangox_iiq_enable(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_iiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_iiq_enableset_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_iiq_enableset, 1 << bit);
+	spin_unlock_irqrestore(&mips_iiq_lock, flags);
+}
+
+static inline void tangox_irq_disable(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_irq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_irq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_irq_enableclr, 1 << bit);
+	spin_unlock_irqrestore(&mips_irq_lock, flags);
+}
+
+static inline void tangox_fiq_disable(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_fiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_fiq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_fiq_enableclr, 1 << bit);
+	spin_unlock_irqrestore(&mips_fiq_lock, flags);
+}
+
+static inline void tangox_iiq_disable(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mips_iiq_lock, flags);
+	if (bit >= 32) 
+		WR_CPU_REG32(CPU_iiq_enableclr_hi, 1 << (bit - 32));
+	else
+		WR_CPU_REG32(CPU_iiq_enableclr, 1 << bit);
+	spin_unlock_irqrestore(&mips_iiq_lock, flags);
+}
+
+static unsigned int tangox_irq_startup(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_irq_enable(x);
+	return 0;
+}
+
+static unsigned int tangox_fiq_startup(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_fiq_enable(x);
+	return 0;
+}
+
+static unsigned int tangox_iiq_startup(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+
+	/* clear any pending interrupt before enabling it */
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+
+	tangox_iiq_enable(x);
+	return 0;
+}
+
+#define	tangox_irq_shutdown tangox_irq_disable
+#define	tangox_fiq_shutdown tangox_fiq_disable
+#define	tangox_iiq_shutdown tangox_iiq_disable
+
+static void tangox_irq_ack(unsigned int x)
+{
+	int bit = x - IRQ_CONTROLLER_IRQ_BASE;
+
+	tangox_irq_disable(x);
+
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_fiq_ack(unsigned int x)
+{
+	int bit = x - FIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_fiq_disable(x);
+
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_iiq_ack(unsigned int x)
+{
+	int bit = x - IIQ_CONTROLLER_IRQ_BASE;
+
+	tangox_iiq_disable(x);
+
+	if (bit >= 32) {
+		WR_CPU_REG32(CPU_edge_rawstat_hi, 1 << (bit - 32));
+	} else {
+		WR_CPU_REG32(CPU_edge_rawstat, 1 << bit);
+	}
+}
+
+static void tangox_irq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_irq_enable(x);
+}
+
+static void tangox_fiq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_fiq_enable(x);
+}
+
+static void tangox_iiq_end(unsigned int x)
+{
+	if (!(irq_desc[x].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		tangox_iiq_enable(x);
+}
+
+/*
+ * our hw_irq_controllers
+ */
+static struct irq_chip tangox_irq_controller = {
+	.typename = "tangox_irq",
+	.startup = tangox_irq_startup,
+	.shutdown = tangox_irq_shutdown,
+	.enable = tangox_irq_enable,
+	.disable = tangox_irq_disable,
+	.ack = tangox_irq_ack,
+	.mask = tangox_irq_disable,
+	.mask_ack = tangox_irq_ack,
+	.unmask = tangox_irq_enable,
+	.end = tangox_irq_end,
+};
+
+static struct irq_chip tangox_fiq_controller = {
+	.typename = "tangox_fiq",
+	.startup = tangox_fiq_startup,
+	.shutdown = tangox_fiq_shutdown,
+	.enable = tangox_fiq_enable,
+	.disable = tangox_fiq_disable,
+	.ack = tangox_fiq_ack,
+	.mask = tangox_fiq_disable,
+	.mask_ack = tangox_fiq_ack,
+	.unmask = tangox_fiq_enable,
+	.end = tangox_fiq_end,
+};
+
+static struct irq_chip tangox_iiq_controller = {
+	.typename = "tangox_iiq",
+	.startup = tangox_iiq_startup,
+	.shutdown = tangox_iiq_shutdown,
+	.enable = tangox_iiq_enable,
+	.disable = tangox_iiq_disable,
+	.ack = tangox_iiq_ack,
+	.mask = tangox_iiq_disable,
+	.mask_ack = tangox_iiq_ack,
+	.unmask = tangox_iiq_enable,
+	.end = tangox_iiq_end,
+};
+
+static struct irqaction irq_cascade = {
+	no_action, IRQF_SHARED, { { 0, } }, "cascade", NULL, NULL
+};
+
+#if defined(CONFIG_TANGO3)
+static int handle_perf_irq(int irqn, void *dummy) 
+{
+	return perf_irq();
+}
+
+static struct irqaction irq_perf_counters = {
+	handle_perf_irq, 0, { { 0, } }, "perf_counter", NULL, NULL
+};
+#endif
+
+void __init arch_init_irq(void)
+{
+	unsigned long x;
+	unsigned long rise = 0;
+	unsigned long fall = 0;
+	unsigned long rise_hi = 0;
+	unsigned long fall_hi = 0;
+
+	/* irq_desc entries 0..7 */
+	mips_cpu_irq_init();
+
+	WR_CPU_REG32(CPU_irq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr, 0xffffffff);
+	WR_CPU_REG32(CPU_irq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_fiq_enableclr_hi, 0xffffffff);
+	WR_CPU_REG32(CPU_iiq_enableclr_hi, 0xffffffff);
+
+	rise = RD_CPU_REG32(CPU_edge_config_rise);
+	fall = RD_CPU_REG32(CPU_edge_config_fall);
+	edge_trig = rise ^ fall;
+	WR_CPU_REG32(CPU_edge_rawstat, 0xffffffff);
+	rise_hi = RD_CPU_REG32(CPU_edge_config_rise_hi);
+	fall_hi = RD_CPU_REG32(CPU_edge_config_fall_hi);
+	edge_trig_hi = rise_hi ^ fall_hi;
+	WR_CPU_REG32(CPU_edge_rawstat_hi, 0xffffffff);
+
+	for (x = IRQ_CONTROLLER_IRQ_BASE; x < IRQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		set_irq_chip_and_handler(x, &tangox_irq_controller, handle_level_irq);
+	}
+
+	for (x = FIQ_CONTROLLER_IRQ_BASE; x < FIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		set_irq_chip_and_handler(x, &tangox_fiq_controller, handle_level_irq);
+	}
+
+	for (x = IIQ_CONTROLLER_IRQ_BASE; x < IIQ_CONTROLLER_IRQ_BASE + IRQ_COUNT; x++) {
+		set_irq_chip_and_handler(x, &tangox_iiq_controller, handle_level_irq);
+	}
+
+	setup_irq(MIPS_CPU_IRQ_BASE + 2, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 3, &irq_cascade);
+	setup_irq(MIPS_CPU_IRQ_BASE + 4, &irq_cascade);
+
+#if defined(CONFIG_TANGO3)
+	if (cp0_perfcount_irq > 0)
+		setup_irq(cp0_perfcount_irq, &irq_perf_counters);
+#endif
+
+	return;
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/Kconfig linux-2.6.29/arch/mips/tangox/Kconfig
--- linux-2.6.29.ref/arch/mips/tangox/Kconfig	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/Kconfig	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,366 @@
+
+#
+# environment selection
+#
+
+#
+# chip revision selection
+#
+
+choice 
+	prompt "Sigma Designs chips"
+	depends on TANGOX
+
+config TANGO2_ES6
+	bool "SMP863x ES6+"
+	select TANGO2_SMP863X
+	select TANGO2
+	help
+	  Support for Sigma Designs SMP863x chip (Tango2 architecture).
+
+config TANGO3_SMP8652
+	bool "SMP8652"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3_8652
+	select TANGO3
+	help 
+	  Support for Sigma Designs SMP8652 chip (Tango3 architecture).
+
+config TANGO3_SMP8654
+	bool "SMP8654"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3_8654
+	select TANGO3
+	help 
+	  Support for Sigma Designs SMP8654 chip (Tango3 architecture).
+
+config TANGO3_SMP8656OTP
+	bool "SMP8656 w/OTP"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3
+	help 
+	  Support for Sigma Designs SMP8656 chip with OTP technology (aka 8656PS4/8656Bxx, Tango3)).
+
+config TANGO3_SMP8656SF
+	bool "SMP8656 w/Serial Flash"
+	select TANGO3_SMP86XX
+	select TANGO3_865X
+	select TANGO3
+	help 
+	  Support for Sigma Designs SMP8656 chip with embedded serial flash (aka 8656ES1/8656ES5/8656Axx/8656Cxx, Tango3)).
+
+config TANGO3_SMP8642
+	bool "SMP8642"
+	select TANGO3_SMP86XX
+	select TANGO3_864X
+	select TANGO3
+	help
+	  Sigma Designs SMP8642 chip (MIPS 74Kf core based), ES2 or above.
+	  Newer compiler may be needed to support 74Kf core (Tango3 architecture).
+
+config TANGO3_SMP8644
+	bool "SMP8644"
+	select TANGO3_SMP86XX
+	select TANGO3_864X
+	select TANGO3
+	help
+	  Sigma Designs SMP8644 chip (MIPS 74Kf core based), ES2 or above.
+	  Newer compiler may be needed to support 74Kf core (Tango3 architecture).
+
+config TANGO3_SMP8646
+	bool "SMP8646"
+	select TANGO3_SMP86XX
+	select TANGO3_864X
+	select TANGO3
+	help
+	  Sigma Designs SMP8646 chip (MIPS 74Kf core based), ES2 or above.
+	  Newer compiler may be needed to support 74Kf core (Tango3 architecture).
+
+config TANGO3_SMP8670
+	bool "SMP8670"
+	select TANGO3_SMP86XX
+	select TANGO3_867X
+	select TANGO3
+	help
+	  Sigma Designs SMP8670 chip (MIPS 24Kf core based), ES1 or above (Tango3).
+
+config TANGO3_SMP8672
+	bool "SMP8672"
+	select TANGO3_SMP86XX
+	select TANGO3_867X
+	select TANGO3
+	help
+	  Sigma Designs SMP8672 chip (MIPS 74Kf core based), ES1 or above (Tango3).
+
+config TANGO3_SMP8674
+	bool "SMP8674"
+	select TANGO3_SMP86XX
+	select TANGO3_867X
+	select TANGO3
+	help
+	  Sigma Designs SMP8674 chip (MIPS 24Kf core based), ES1 or above (Tango3).
+
+endchoice
+
+config TANGO2
+	bool
+
+config TANGO3
+	bool
+
+config TANGO2_SMP863X
+	bool
+	select IRQ_CPU
+	select HW_HAS_PCI
+	select NR_CPUS_DEFAULT_1
+	select USB_ARCH_HAS_OHCI
+	select USB_ARCH_HAS_EHCI
+
+config TANGO3_SMP86XX
+	bool
+	select CRYPTO_SHA256
+	select IRQ_CPU
+	select MIPS_CPU_SCACHE
+	select NR_CPUS_DEFAULT_1
+	select USB_ARCH_HAS_OHCI
+	select USB_ARCH_HAS_EHCI
+
+config TANGO3_865X
+	bool 
+	select HW_HAS_PCI
+
+config TANGO3_867X
+	bool 
+	select HW_HAS_PCI
+
+config TANGO3_864X
+	bool
+
+comment "More configurations"
+	depends on TANGOX
+
+config TANGOX_SYSTEMRAM_ACTUALSIZE
+	int "System RAM size (in MB)"
+	depends on TANGOX
+	default 64
+	help
+	 This is the default amount of RAM available to the Linux kernel. It can be
+	 override with "mem=" command line option.
+
+config TANGOX_IGNORE_CMDLINE
+	bool "Ignore YAMON, XENV & memcfg command line"
+	depends on TANGOX
+	default n
+	help
+	 If you say  yes, boot command line from  YAMON, XENV & memcfg
+	 will be ignored. You can then use CONFIG_CMDLINE to force the
+	 kernel command line.
+
+config TANGOX_PROM_CONSOLE
+	bool "Register an early console"
+	depends on TANGOX
+	default n
+	help
+	 If you say yes, an light console will be available very early
+	 in the  boot process,  this is useful  if the  kernel crashes
+	 before reaching  the main console  code. The console  will be
+	 automatically replaced by the normal one after.
+	 ### NOTE: This console can only do output ###
+
+config TANGOX_FIXED_FREQUENCIES
+	bool "Specified fixed frequencies"
+	depends on TANGOX
+	default n 
+	help
+	 To specify, statically, the frequencies for CPU, System, and Base.
+	 Normally this is only used in experimental purpose where PLL may be
+	 set differently (typical for simulation or FPGA).
+
+config TANGOX_BASE_FREQUENCY
+	int "Base Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 27000000
+	help
+	 Base frequency (corresponding to XTAL in).
+
+config TANGOX_CPU_FREQUENCY
+	int "CPU Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 300000000
+	help
+	 CPU frequency.
+
+config TANGOX_SYS_FREQUENCY
+	int "System Frequency"
+	depends on TANGOX_FIXED_FREQUENCIES
+	default 200000000
+	help
+	 System frequency.
+
+config TANGOX_DSP_FREQUENCY
+ 	int "DSP Frequency"
+ 	depends on TANGOX_FIXED_FREQUENCIES
+ 	default 200000000
+ 	help
+ 	 DSP frequency.
+ 
+config TANGOX_UART_USE_SYSCLK
+	bool "Use system clock for UART"
+	depends on TANGOX
+	default n
+	help
+	 If you  say yes here, the UART  clock will be  derivated from the
+	 system bus clock. If  you say  no, the  XTAL_in clock  is used
+	 instead.
+
+config TANGOX_USE_TLB_REMAP_DRAM1
+	bool "Use TLB to access DRAM1"
+	depends on TANGO2_SMP863X 
+	default n
+	help
+	 If  you say yes  here, kernel  access to  DRAM1 will  be done
+	 using TLB implementation. gbus() funcs will use an ioremapped
+	 address to access this area of memory. If you say no, special
+	 CPU remap registers are used instead.
+
+#
+# XENV stuffs
+#
+comment "XENV support"
+	depends on TANGOX
+
+config TANGOX_XENV_READ
+	bool "Read config from XENV"
+	depends on TANGOX
+ 	select CRYPTO_SHA1 
+ 	select CRYPTO_SHA256 if TANGO3 
+	help
+	 If you  say yes  here, board configuration  (enabled devices,
+	 pci irq routing,  ...) will be read from  xenv space.
+
+config TANGOX_XENV_DUMP
+	bool "Dump XENV content at boot"
+	depends on TANGOX_XENV_READ
+	default n
+
+config TANGOX_XENV_READ_SAFE
+	bool "Don't boot if XENV invalid"
+	depends on TANGOX_XENV_READ
+	help
+	 If you say yes here and XENV content is invalid, linux wont boot.
+
+menu "XENV failsafe/override values"
+	depends on TANGOX && (!TANGOX_XENV_READ_SAFE)
+
+config TANGOX_XENV_DEF_CS0_SIZE
+	hex "CS0 size (flash0)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS1_SIZE
+	hex "CS1 size (flash1)"
+	default 0x0
+
+config TANGOX_XENV_DEF_CS2_SIZE
+	hex "CS2 size (flash2)"
+	default 0x400000
+
+config TANGOX_XENV_DEF_CS3_SIZE
+	hex "CS3 size (flash3)"
+	default 0x0
+
+config TANGOX_XENV_DEF_UART0
+	bool "UART0 enabled"
+	default y
+
+config TANGOX_XENV_DEF_UART1
+	bool "UART1 enabled"
+	default y
+
+config TANGOX_XENV_DEF_BAUDRATE
+	int "Default baudrate"
+	default 115200
+
+config TANGOX_XENV_DEF_CONSOLE_UART_PORT
+	int "Console UART port"
+	default 0
+
+config TANGOX_XENV_DEF_ENET
+	bool "Ethernet enabled"
+	default n
+
+config TANGOX_XENV_DEF_FIP
+	bool "FIP enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CM
+	bool "I2CM enabled"
+	default n
+
+config TANGOX_XENV_DEF_I2CS
+	bool "I2CS enabled"
+	default n
+
+config TANGOX_XENV_DEF_BMIDE
+	bool "BM IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_ISAIDE
+	bool "ISA IDE controller enabled"
+	default n
+
+config TANGOX_XENV_DEF_IR
+	bool "IR enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCIHOST
+	bool "PCI Host enabled"
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1
+	bool "PCI device 1 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID1_IRQ
+	hex "PCI device 1 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID1
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID2
+	bool "PCI device 2 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID2_IRQ
+	hex "PCI device 2 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID2
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID3
+	bool "PCI device 3 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID3_IRQ
+	hex "PCI device 3 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID3
+	default 0x0
+
+config TANGOX_XENV_DEF_PCI_ID4
+	bool "PCI device 4 enabled"
+	depends on TANGOX_XENV_DEF_PCIHOST
+	default n
+
+config TANGOX_XENV_DEF_PCI_ID4_IRQ
+	hex "PCI device 4 IRQ route"
+	depends on TANGOX_XENV_DEF_PCIHOST && TANGOX_XENV_DEF_PCI_ID4
+	default 0x0
+
+config TANGOX_XENV_DEF_USB
+	bool "USB enabled"
+	default n
+
+endmenu
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/Makefile linux-2.6.29/arch/mips/tangox/Makefile
--- linux-2.6.29.ref/arch/mips/tangox/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/Makefile	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,14 @@
+#
+# Makefile for SigmaDesigns Tango2/Tango3 board
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y += irq.o setup.o prom.o gbus.o xenv_config.o delay.o console.o
+
+obj-$(CONFIG_TANGO2) += cpucache.o
+
+obj-$(CONFIG_TANGOX_XENV_READ) += sha.o xenv.o xenv_config.o
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/prom.c linux-2.6.29/arch/mips/tangox/prom.c
--- linux-2.6.29.ref/arch/mips/tangox/prom.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/prom.c	2011-05-24 12:41:09.913376515 -0700
@@ -0,0 +1,793 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2009
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+#include <linux/module.h>
+#include <asm/cacheflush.h>
+
+#include "setup.h"
+
+#if defined(CONFIG_TANGO3) 
+#include "xenv.h"
+#include "xenvkeys.h"
+#endif
+
+/*
+ * em8xxx_sys_frequency may be used later in the serial  code, DON'T mark
+ * it as initdata
+ */
+unsigned long em8xxx_sys_frequency;
+unsigned long em8xxx_cpu_frequency;
+unsigned long orig_cpu_freq;
+unsigned long em8xxx_kmem_start;
+unsigned long em8xxx_kmem_size;
+unsigned long em8xxx_sys_clkgen_pll;
+unsigned long em8xxx_sys_premux;
+unsigned long em8xxx_sys_mux;
+#if defined(CONFIG_TANGO3)
+unsigned long max_remap_size = MAX_KERNEL_MEMSIZE;
+#endif 
+
+unsigned long tangox_chip_id(void);
+int is_tango2_chip(void);
+int is_tango3_chip(void);
+int is_tango3_es1(void);
+int is_tango3_es2(void);
+
+/*
+ * we will restore remap registers before rebooting
+ */
+#ifdef CONFIG_TANGO2
+unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+unsigned long em8xxx_remap_registers[9];
+#endif 
+
+/*
+ * helper to access base registers
+ */
+#define RD_BASE_REG32(r)	\
+		gbus_read_reg32(REG_BASE_system_block + (r))
+
+/*
+ * return system type (/proc/cpuinfo)
+ */
+const char *get_system_type(void)
+{
+	return "Sigma Designs TangoX";
+}
+
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+unsigned long tangox_get_pllclock(int pll)
+{
+	return(0);
+}
+
+unsigned long tangox_get_sysclock(void)
+{
+	return(CONFIG_TANGOX_SYS_FREQUENCY);
+}
+
+unsigned long tangox_get_cpuclock(void)
+{
+	return(CONFIG_TANGOX_CPU_FREQUENCY);
+}
+
+unsigned long tangox_get_dspclock(void)
+{
+	return(CONFIG_TANGOX_DSP_FREQUENCY);
+}
+#else
+unsigned long tangox_get_pllclock(int pll)
+{
+	unsigned long sys_clkgen_pll, sysclk_mux;
+	unsigned long n, m, freq, k, step;
+
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux) & 0xf01;
+	if ((sysclk_mux & 0x1) == 0) {
+		freq = TANGOX_BASE_FREQUENCY;
+		goto done;
+	}
+
+	sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen0_pll + (pll * 0x8));
+
+	/* Not using XTAL_IN, cannot calculate */
+	if ((sys_clkgen_pll & 0x07000000) != 0x01000000)
+		goto freq_error;
+
+#ifdef CONFIG_TANGO2
+	m = (sys_clkgen_pll >> 16) & 0x1f;
+	n = sys_clkgen_pll & 0x000003ff;
+	k = (pll) ? 0 : ((sys_clkgen_pll >> 14) & 0x3); 
+	step = 2;
+#elif defined(CONFIG_TANGO3)
+	if (pll != 0) { /* PLL1/PLL2 */
+		m = (sys_clkgen_pll >> 16) & 0x1;
+		n = sys_clkgen_pll & 0x0000007f;
+		k = (sys_clkgen_pll >> 13) & 0x7;
+		step = 1;
+	} else {
+		m = (sys_clkgen_pll >> 16) & 0x1f;
+		n = sys_clkgen_pll & 0x000003ff;
+		k = (sys_clkgen_pll >> 14) & 0x3; 
+		step = 2;
+	}
+#else
+#error Unsupported platform.
+#endif
+	freq = ((TANGOX_BASE_FREQUENCY / (m + step)) * (n + step)) / (1 << k);
+
+done:
+	return(freq);
+
+freq_error:
+	printk("%s:%d don't know how to calculate the frequency ..\n", __FILE__, __LINE__);
+	BUG();
+	return(0);
+}
+
+static unsigned long tangox_get_clock(unsigned int clk_dom)
+{
+	unsigned long sysclk_mux, sysclk_premux;
+	unsigned long div, mux, pll, pll_freq;
+	static const unsigned char dividers[3][12] = {
+		{ 2, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 },
+		{ 2, 2, 2, 3, 3, 2, 3, 2, 4, 2, 4, 2 }, 
+#ifdef CONFIG_TANGO2
+		{ 2, 4, 3, 3, 3, 3, 2, 2, 4, 4, 2, 2 },
+#else
+		{ 2, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4 },
+#endif
+	};
+
+	sysclk_mux = RD_BASE_REG32(SYS_sysclk_mux) & 0xf01;
+	sysclk_premux = RD_BASE_REG32(SYS_sysclk_premux);
+	pll = sysclk_premux & 0x3;
+
+	if (((pll_freq = tangox_get_pllclock(pll)) == 0) || (clk_dom >= 3))
+		goto freq_error;
+	else if ((mux = ((sysclk_mux >> 8) & 0xf)) >= 12)
+		goto freq_error; /* invalid mux value */
+
+	div = (unsigned long)dividers[clk_dom][mux];
+
+	return(pll_freq / div);
+
+freq_error:
+	return(0);
+}
+
+unsigned long tangox_get_sysclock(void)
+{
+	return(tangox_get_clock(0));
+}
+
+unsigned long tangox_get_cpuclock(void)
+{
+	return(tangox_get_clock(1));
+}
+
+unsigned long tangox_get_dspclock(void)
+{
+	return(tangox_get_clock(2));
+}
+#endif
+
+extern int do_syslog(int type, char * buf, int len);
+extern int __init xenv_config(void);
+extern void __init tangox_device_info(void);
+extern const char *tangox_xenv_cmdline(void);
+
+#if defined(CONFIG_TANGO3)
+#define REMAP_SIZE	0x04000000UL
+static inline void update_remap(unsigned int remap, unsigned long mapaddr)
+{
+	if (gbus_read_reg32(REG_BASE_cpu_block + CPU_remap + (remap * 4)) != mapaddr) {
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + (remap * 4), mapaddr);
+		iob();
+	}
+	em8xxx_remap_registers[remap] = mapaddr & 0xfc000000UL;
+}
+
+#ifdef CONFIG_TANGOX_XENV_READ
+unsigned long __init dram_remap_setup(unsigned long dsize)
+{
+	unsigned long max_d0_size = 0, max_d1_size = 0, tmp, tsize = 0, fd0 = 0;
+	unsigned long dx_sizes[2], dx_addrs[2];
+	unsigned int size = sizeof(unsigned long), i, j;
+
+	/* check the boundaries for DRAM0 and DRAM1 */
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_RUAMM0_GA, &tmp, &size) == 0) 
+			&& (size == sizeof(unsigned long))) 
+		fd0 = max_d0_size = tmp - MEM_BASE_dram_controller_0;
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_RUAMM1_GA, &tmp, &size) == 0) 
+			&& (size == sizeof(unsigned long))) 
+		max_d1_size = tmp - MEM_BASE_dram_controller_1;
+
+	/* Max. dynamic remap can do only 384MB */
+	max_d0_size = (max_d0_size > 0x18000000UL) ? 0x18000000UL : max_d0_size;
+	max_d1_size = (max_d1_size > 0x18000000UL) ? 0x18000000UL : max_d1_size;
+
+	printk("Desired kernel memory size: 0x%08lx\n", dsize);
+	printk("Max. DRAM0/1 size allowed: 0x%08lx/0x%08lx\n", max_d0_size, max_d1_size);
+
+	if (gbus_read_reg32(REG_BASE_cpu_block + CPU_remap + (REMAP_IDX * 4)) >= MEM_BASE_dram_controller_1) {
+		/* Use DRAM1 first */
+		dx_sizes[0] = max_d1_size;
+		dx_sizes[1] = max_d0_size;
+		dx_addrs[0] = MEM_BASE_dram_controller_1;
+		dx_addrs[1] = MEM_BASE_dram_controller_0;
+	} else {
+		/* Use DRAM0 first */
+		dx_sizes[0] = max_d0_size;
+		dx_sizes[1] = max_d1_size;
+		dx_addrs[0] = MEM_BASE_dram_controller_0;
+		dx_addrs[1] = MEM_BASE_dram_controller_1;
+	}
+
+	for (i = REMAP_IDX, j = 0; (dx_sizes[0] >= REMAP_SIZE) && (dsize >= REMAP_SIZE) && (i < 8); i++, j++) {
+		update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+		dx_sizes[0] -= REMAP_SIZE;
+		dsize -= REMAP_SIZE;
+		tsize += REMAP_SIZE;
+		printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+			dx_addrs[0] + (j * REMAP_SIZE), REMAP_SIZE, i);
+	}
+	if (i < 8) {
+		if (dsize > 0) {
+			if (dsize < REMAP_SIZE) {
+				if (dx_sizes[0] >= dsize) {
+					update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+					tsize += dsize;
+					printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+						dx_addrs[0] + (j * REMAP_SIZE), dsize, i);
+					goto done;
+				} else if (dx_sizes[0] > dx_sizes[1]) {
+					update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+					tsize += dx_sizes[0];
+					printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+						dx_addrs[0] + (j * REMAP_SIZE), dx_sizes[0], i);
+					goto done;
+				}
+			} else {
+				if (dx_sizes[0] > dx_sizes[1]) {
+					update_remap(i, dx_addrs[0] + (j * REMAP_SIZE));
+					tsize += dx_sizes[0];
+					printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+						dx_addrs[0] + (j * REMAP_SIZE), dx_sizes[0], i);
+					goto done;
+				}
+			}
+		}
+	} else {
+		/* Check to see if the last, fixed remap works? */
+		if (dsize > 0) {
+			unsigned long msz = (fd0 > 0x0c000000UL) ? (fd0 - 0x0c000000UL) : 0UL;
+			msz = (msz > dsize) ? dsize : msz;
+			if (msz) {
+				tsize += msz;
+				printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+					MEM_BASE_dram_controller_0 + 0x0c000000UL, msz, i);
+			}
+		}
+		goto done;
+	}
+
+	for (j = 0; (dx_sizes[1] >= REMAP_SIZE) && (dsize >= REMAP_SIZE) && (i < 8); i++, j++) {
+		update_remap(i, dx_addrs[1] + (j * REMAP_SIZE));
+		dx_sizes[1] -= REMAP_SIZE;
+		dsize -= REMAP_SIZE;
+		tsize += REMAP_SIZE;
+		printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+			dx_addrs[1] + (j * REMAP_SIZE), REMAP_SIZE, i);
+	}
+	if (i < 8) {
+		if (dsize > 0) {
+			unsigned long msz = (dx_sizes[1] > dsize) ? dsize : dx_sizes[1];
+			if (msz) {
+				update_remap(i, dx_addrs[1] + (j * REMAP_SIZE));
+				tsize += msz;
+				printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+					dx_addrs[1] + (j * REMAP_SIZE), msz, i);
+			}
+			goto done;
+		}
+	} else {
+		/* Check to see if the last, fixed remap works? */
+		if (dsize > 0) {
+			unsigned long msz = (fd0 > 0x0c000000UL) ? (fd0 - 0x0c000000UL) : 0UL;
+			msz = (msz > dsize) ? dsize : msz;
+			if (msz) {
+				tsize += msz;
+				printk(" Mapped 0x%08lx(size 0x%08lx) via remap%d\n", 
+					MEM_BASE_dram_controller_0 + 0x0c000000UL, msz, i);
+			}
+		}
+		goto done;
+	}
+
+done:
+	printk("Final kernel memory size: 0x%08lx\n", tsize);
+	return(tsize);
+}
+#endif
+
+void __init update_lrrw_kend(unsigned long kend)
+{
+#ifdef CONFIG_TANGOX_XENV_READ
+//	xenv_set((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_KERNEL_END, &kend, 0, sizeof(kend));
+#endif
+}
+#endif
+
+void __init tangox_mem_setup(unsigned long size)
+{
+	unsigned long em8xxx_kmem_end;
+#if defined(CONFIG_TANGO3)
+#ifdef CONFIG_TANGOX_XENV_READ
+	em8xxx_kmem_size = dram_remap_setup(size);
+#else
+	em8xxx_kmem_size = size;
+#endif
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(CPU_REMAP_SPACE);
+	update_lrrw_kend(em8xxx_kmem_end);
+#else
+	/*
+	 * check/fill the memcfg
+	 */
+	memcfg_t *m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0 + FM_MEMCFG);
+	em8xxx_kmem_size = ((size + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+	em8xxx_kmem_end = KSEG1ADDR(em8xxx_kmem_start + em8xxx_kmem_size) - KSEG1ADDR(MEM_BASE_dram_controller_0);
+	if (is_valid_memcfg(m) == 0) {
+		printk("Invalid MEMCFG, creating new one at 0x%08x.\n", MEM_BASE_dram_controller_0 + FM_MEMCFG);
+		memset(m, 0, sizeof (memcfg_t));
+		m->signature = MEMCFG_SIGNATURE;
+		m->dram0_size = TANGOX_SYSTEMRAM_ACTUALSIZE;
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+	} else {
+		printk("Valid MEMCFG found at 0x%08x.\n", MEM_BASE_dram_controller_0 + FM_MEMCFG);
+		m->kernel_end = em8xxx_kmem_end;
+		gen_memcfg_checksum(m);
+	}
+#endif
+
+	return;
+}
+
+void __init prom_init(void)
+{
+	extern char _text;
+	unsigned long offset;
+	int clksel, xenv_res = 0, i;
+	char *revStr = NULL;
+
+#if 0
+	/* For emulator, setup registers that typically got setup by bootloader */
+	/* Temporary HACK */
+	/* UART0/1 UART mode */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart0_gpio_mode, 0xff00);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_uart1_gpio_mode, 0xff00);
+
+	/* Set interrupt attributes, clear/disable all external interrupts */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_irq_enableclr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_clr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_clr, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_set, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_set, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_rawstat, 0xffffffff);
+
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_irq_enableclr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_clr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_clr_hi, 0xffffffff);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_rise_set_hi, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_config_fall_set_hi, 0);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_edge_rawstat_hi, 0xffffffff);
+#endif
+	/*
+	 * save remap registers for reboot time
+	 */
+	for (i = 0;
+#ifdef CONFIG_TANGO2
+		i < 5;
+#elif defined(CONFIG_TANGO3)
+		i < 8;
+#endif
+		i++) {
+		em8xxx_remap_registers[i] = gbus_read_reg32(REG_BASE_cpu_block + CPU_remap + (i * 4));
+	}
+#if defined(CONFIG_TANGO3)
+	em8xxx_remap_registers[8] = MEM_BASE_dram_controller_0 + 0x0c000000UL; /* Fixed "remap" */
+#endif
+
+	/* 
+	 * Set remap so that 0x1fc00000 and 0x0 back to they should be...
+	 */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap, 0x1fc00000);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap1, 0x0);
+	iob();
+	
+#if defined(CONFIG_TANGO2_SMP863X)
+	printk("Configured for SMP863%c (revision %s), ",
+			'x', "ES6+/RevA+"
+	      );
+#elif defined(CONFIG_TANGO3_SMP86XX)
+	printk("Configured for SMP%s, ",
+#if defined(CONFIG_TANGO3_865X)
+			"865x"
+#elif defined(CONFIG_TANGO3_864X)
+			"864x"
+#elif defined(CONFIG_TANGO3_867X)
+			"867x"
+#endif
+	      );
+#else
+#error Unsupported platform.
+#endif
+	printk("detected SMP%lx (revision ", (tangox_chip_id()>>16)&0xffff);
+#if defined(CONFIG_TANGO2)
+	if (is_tango2_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x81: /* ES1-3 */
+				revStr = "ES1-3";
+				break;
+			case 0x82: /* ES4-5 */
+				revStr = "ES4-5";
+				break;
+			case 0x83: /* ES6/RevA */
+				revStr = "ES6/RevA";
+				break;
+			case 0x84: /* ES7/RevB */
+				revStr = "ES7/RevB";
+				break;
+			case 0x85: /* ES8 */
+				revStr = "ES8";
+				break;
+			case 0x86: /* ES9/RevC */
+				revStr = "ES9/RevC";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} 
+#elif defined(CONFIG_TANGO3)
+	if (is_tango3_chip()) {
+		unsigned long revision = tangox_chip_id() & 0xff;
+		switch(revision) {
+			case 0x1: /* ES1 */
+				revStr = "ES1";
+				break;
+			case 0x2: /* ES2 */
+				revStr = "ES2";
+				break;
+			case 0x3: /* ES3 */
+				revStr = "ES3";
+				break;
+			case 0x4: /* ES4 */
+				revStr = "ES4";
+				break;
+			case 0x5: /* ES5 */
+				revStr = "ES5";
+				break;
+			case 0x6: /* ES6 */
+				revStr = "ES6";
+				break;
+			default: /* Unknown */
+				revStr = "unknown";
+				break;
+		}
+	} 
+#endif
+	else
+		revStr = "unknown";
+	
+	printk("%s).\n", revStr);
+#ifdef CONFIG_TANGOX_FIXED_FREQUENCIES
+	printk("Fixed CPU/System/DSP Frequencies: %ld.%02ld/%ld.%02ld/%ld.%02ldMHz\n",
+		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100,
+		tangox_get_dspclock() / 1000000, (tangox_get_dspclock() / 10000) % 100);
+#else
+	printk("Detected CPU/System/DSP Frequencies: %ld.%02ld/%ld.%02ld/%ld.%02ldMHz\n",
+		tangox_get_cpuclock() / 1000000, (tangox_get_cpuclock() / 10000) % 100,
+		tangox_get_sysclock() / 1000000, (tangox_get_sysclock() / 10000) % 100,
+		tangox_get_dspclock() / 1000000, (tangox_get_dspclock() / 10000) % 100);
+#endif
+
+	/*
+	 * read xenv  configuration, we  need it quickly  to configure
+	 * console accordingly.
+	 *
+	 * NOTE: We  may stay STUCK in  this if safe  mode is required
+	 * and XENV is not valid !
+	 */
+	xenv_res = xenv_config();
+
+	/*
+	 * calculate cpu & sys frequency (may be needed for uart init)
+	 */
+	orig_cpu_freq = em8xxx_cpu_frequency = tangox_get_cpuclock();
+	em8xxx_sys_frequency = tangox_get_sysclock();
+
+	em8xxx_sys_clkgen_pll = RD_BASE_REG32(SYS_clkgen_pll);
+	em8xxx_sys_premux = RD_BASE_REG32(SYS_sysclk_premux) & 0x3;
+	em8xxx_sys_mux = RD_BASE_REG32(SYS_sysclk_mux) & 0xf01;
+
+	/*
+	 * program the right clock divider in both uart
+	 */
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	clksel = 0;
+#else
+	clksel = 1;
+#endif
+#if defined(CONFIG_TANGO3)
+ 	if ((((tangox_chip_id() >> 16) & 0xfffe) == 0x8656) || (((tangox_chip_id() >> 16) & 0xfffe) == 0x8672))
+ 		gbus_write_reg32(REG_BASE_system_block + 0x700 + CPU_UART_CLKSEL, clksel);
+ 	else
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL, clksel);
+#else
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART0_base + CPU_UART_CLKSEL, clksel);
+#endif
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART1_base + CPU_UART_CLKSEL, clksel);
+#if defined(CONFIG_TANGO3)
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_UART2_base + CPU_UART_CLKSEL, clksel);
+#endif
+
+	/*
+	 * show KERN_DEBUG message on console
+	 */
+	do_syslog(8, NULL, 8);
+
+#ifdef CONFIG_TANGOX_PROM_CONSOLE
+	/* initialize uart and register early console */
+	prom_console_register();
+#endif
+
+	/* warn user if we use failsafe values for xenv */
+	if (xenv_res)
+		printk("Invalid XENV content, using failsafe values\n");
+	tangox_device_info();
+
+	/*
+	 * compute kernel memory start address/size
+	 * _text section gives kernel address start
+	 */
+	em8xxx_kmem_start = ((unsigned long)(&_text)) & PAGE_MASK;
+
+#if ((CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE<<20) > MAX_KERNEL_MEMSIZE)
+	em8xxx_kmem_size = ((MAX_KERNEL_MEMSIZE + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+#else
+	em8xxx_kmem_size = (((CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE << 20) + em8xxx_kmem_start) & 0xfff00000) - em8xxx_kmem_start;
+#endif
+
+	tangox_mem_setup(em8xxx_kmem_size);
+
+	/*
+	 * tell kernel about available memory size/offset
+	 */
+#if defined(CONFIG_TANGO3)
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(CPU_REMAP_SPACE);
+	add_memory_region(CPU_REMAP_SPACE + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#else
+	offset = KSEG1ADDR(em8xxx_kmem_start) - KSEG1ADDR(MEM_BASE_dram_controller_0);
+	add_memory_region(MEM_BASE_dram_controller_0 + offset, em8xxx_kmem_size, BOOT_MEM_RAM);
+#endif
+
+	arcs_cmdline[CL_SIZE - 1] = '\0';
+#ifndef CONFIG_TANGOX_IGNORE_CMDLINE
+	/*
+	 * set up correct linux command line according to XENV, memcfg
+	 * and YAMON args, if not told to ignore them
+	 */
+#ifdef CONFIG_TANGOX_XENV_READ
+	/* If specified by xenv, override the command line */
+	if (tangox_xenv_cmdline())
+		{char *p; strcpy(arcs_cmdline, CONFIG_CMDLINE); strcat(arcs_cmdline, " "); p=strstr(tangox_xenv_cmdline(), "mem="); if (p) strncat(arcs_cmdline, p, 8); else strcat(arcs_cmdline, "mem=128M"); strcat(arcs_cmdline, " "); p=strstr(tangox_xenv_cmdline(), "flashrecovery=1"); if (p) strcat(arcs_cmdline, " flashrecovery=1"); strcat(arcs_cmdline, " quiet"); printk("cmdline=\"%s\"\n", arcs_cmdline);} /* [jmy] */
+#ifdef CONFIG_CMDLINE
+	else
+		strncpy(arcs_cmdline, CONFIG_CMDLINE, CL_SIZE - 1);
+#endif
+#else
+	strncpy(arcs_cmdline, CONFIG_CMDLINE, CL_SIZE - 1);
+#endif
+
+	/* If specified by memcfg, override the command line */
+//	if (m->linux_cmd != 0 && strnlen((char *)KSEG1ADDR(m->linux_cmd), CL_SIZE - 1) > 0)
+//disabled. e.m. 2006feb3rd		strncpy(arcs_cmdline, (char *)KSEG1ADDR(m->linux_cmd), CL_SIZE - 1);
+
+	/* take regular args given by bootloader */
+	if ((fw_arg0 > 1) && (fw_arg0 < 65)) { /* Up to 64 arguments */
+		int argc, i, pos;
+		char **argv;
+
+		argc = fw_arg0;
+		arcs_cmdline[0] = '\0';
+		argv = (char **) fw_arg1;
+		pos = 0;
+		for (i = 1; i < argc; i++) {
+			int len;
+
+			len = strnlen(argv[i], CL_SIZE - 1);
+			if (pos + 1 + len + 1 > sizeof (arcs_cmdline))
+				break;
+			if (pos)
+				arcs_cmdline[pos++] = ' ';
+			strncpy(arcs_cmdline + pos, argv[i], CL_SIZE - (pos + 1));
+			pos += len;
+		}
+	}
+#else
+#ifdef CONFIG_CMDLINE
+	strncpy(arcs_cmdline, CONFIG_CMDLINE, CL_SIZE - 1);
+#endif
+#endif /* !CONFIG_TANGOX_IGNORE_CMDLINE */
+
+	mips_machtype = MACH_TANGOX;
+	return;
+}
+
+void __init prom_free_prom_memory(void)
+{
+	return;
+}
+
+EXPORT_SYMBOL(tangox_get_sysclock);
+EXPORT_SYMBOL(tangox_get_cpuclock);
+EXPORT_SYMBOL(tangox_get_dspclock);
+EXPORT_SYMBOL(tangox_get_pllclock);
+
+unsigned long tangox_chip_id(void)
+{
+	unsigned long chip_id = 0;
+	if (chip_id == 0)
+		chip_id = ((gbus_read_reg32(REG_BASE_host_interface + PCI_REG0) & 0xffff) << 16) |
+				(gbus_read_reg32(REG_BASE_host_interface + PCI_REG1) & 0xff);
+	return chip_id;
+}
+
+int is_tango2_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return (chip == 0x8630) ? 1 : 0;
+}
+
+static inline int is_tango2_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	return (is_tango2_chip() && rev == revid) ? 1 : 0;
+}
+
+int is_tango2_es123(void)
+{
+	return(is_tango2_revision(0x81));
+}
+
+int is_tango2_es45(void)
+{
+	return(is_tango2_revision(0x82));
+}
+
+int is_tango2_es6(void)
+{
+	return(is_tango2_revision(0x83));
+}
+
+int is_tango2_es7(void)
+{
+	return(is_tango2_revision(0x84));
+}
+
+int is_tango2_es89(void)
+{
+	return(is_tango2_revision(0x85) || is_tango2_revision(0x86));
+}
+
+static inline int is_tango3_revision(unsigned char revid)
+{
+	unsigned char rev = tangox_chip_id() & 0xff;
+	unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+	if (!is_tango3_chip())
+		return(0);
+	else {
+		switch(chip_id) {
+			case 0x8652:
+			case 0x8672:
+			case 0x8670:
+			case 0x8656:
+			case 0x8646:
+				rev += 2;
+			case 0x8654:
+			case 0x8644:
+				return((rev == revid) ? 1 : 0);
+			default:
+				return(0);
+		}
+	}
+}
+
+int is_tango3_chip(void)
+{
+	unsigned long chip = (tangox_chip_id()>>16) & 0xfff0;
+	return ((chip == 0x8640) || (chip == 0x8650) || (chip == 0x8670)) ? 1 : 0;
+}
+
+int is_tango3_es1(void)
+{
+	return(is_tango3_revision(0x1));
+}
+
+int is_tango3_es2(void)
+{
+	return(is_tango3_revision(0x2));
+}
+
+int is_tango3_es3(void)
+{
+	return(is_tango3_revision(0x3));
+}
+
+int is_tango3_es4(void)
+{
+	return(is_tango3_revision(0x4));
+}
+
+int is_tango3_es5(void)
+{
+	return(is_tango3_revision(0x5));
+}
+
+void tangox_flush_cache_all(void)
+{
+	__flush_cache_all();
+}
+
+EXPORT_SYMBOL(tangox_flush_cache_all);
+EXPORT_SYMBOL(tangox_chip_id);
+EXPORT_SYMBOL(is_tango2_chip);
+EXPORT_SYMBOL(is_tango3_chip);
+EXPORT_SYMBOL(is_tango2_es123);
+EXPORT_SYMBOL(is_tango2_es45);
+EXPORT_SYMBOL(is_tango2_es6);
+EXPORT_SYMBOL(is_tango2_es7);
+EXPORT_SYMBOL(is_tango2_es89);
+EXPORT_SYMBOL(is_tango3_es1);
+EXPORT_SYMBOL(is_tango3_es2);
+EXPORT_SYMBOL(is_tango3_es3);
+EXPORT_SYMBOL(is_tango3_es4);
+EXPORT_SYMBOL(is_tango3_es5);
+EXPORT_SYMBOL(em8xxx_kmem_size);
+EXPORT_SYMBOL(em8xxx_kmem_start);
+#if defined(CONFIG_TANGO3)
+EXPORT_SYMBOL(max_remap_size);
+EXPORT_SYMBOL(em8xxx_remap_registers);
+#endif
+
+int tangox_get_order(unsigned long size)
+{
+	return(get_order(size));
+}
+EXPORT_SYMBOL(tangox_get_order);
+
+void tangox_do_timer(unsigned long ticks)
+{
+	extern void do_timer(unsigned long ticks);
+
+	write_seqlock(&xtime_lock);
+	do_timer(ticks);
+	write_sequnlock(&xtime_lock);
+}
+  
+EXPORT_SYMBOL(tangox_do_timer);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/setup.c linux-2.6.29/arch/mips/tangox/setup.c
--- linux-2.6.29.ref/arch/mips/tangox/setup.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/setup.c	2011-05-24 12:40:01.553953296 -0700
@@ -0,0 +1,508 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright (C) 2009 Sigma Designs, Inc.
+ * arch/mips/tangox/setup.c
+ *     The setup file for tango2/tango3
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/serial_8250.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <asm/reboot.h>
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+#include <asm/time.h>
+#include <asm/serial.h>
+
+#include "setup.h"
+
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+extern unsigned long em86xx_tlb_dram1_map_base;
+extern unsigned long em86xx_tlb_dram1_map_size;
+#endif
+
+/*
+ * helpers to access cpu block registers
+ */
+#define RD_CPU_REG32(r)	\
+		gbus_read_reg32(REG_BASE_cpu_block + (r))
+
+#define WR_CPU_REG32(r, v)	\
+		gbus_write_reg32(REG_BASE_cpu_block + (r), (v))
+
+#ifdef CONFIG_PCI
+extern void tangox_pci_shutdown(void);
+#endif
+
+#ifdef CONFIG_TANGO2
+/*
+ * we use xrpc to reboot
+*/
+struct xrpc_block_header {
+	u32 callerid;
+	u32 xrpcid;
+
+	u32 param0;
+	u32 param1;
+	u32 param2;
+	u32 param3;
+	u32 param4;
+
+	u32 headerandblocksize;
+};
+
+#define XRPC_ID_REBOOT		19
+#define SOFT_IRQ_XRPC		(1 << 4)
+#endif
+
+void tangox_machine_restart(char *command)
+{
+	int i;
+#ifdef CONFIG_TANGO2
+	unsigned long tmp;
+ 	struct xrpc_block_header *pB;
+	unsigned long base_addr;
+	int loop;
+#endif
+
+        local_irq_disable();
+
+#ifdef CONFIG_PCI
+	tangox_pci_shutdown();
+#endif
+
+#if defined(CONFIG_TANGO2) 
+	/* Resetting TangoX EHCI */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1410);
+	tmp &= ~1;
+	gbus_write_reg32(REG_BASE_host_interface + 0x1410, tmp);
+	mdelay(5);
+
+	/* Resetting TangoX OHCI */
+	gbus_write_reg32(REG_BASE_host_interface + 0x1514, 1<<31);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1504, 0);
+	mdelay(5);
+
+	/* Resetting internal USB PHY in USB Control space */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1700);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp | 1);
+	udelay(30);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp);
+	mdelay(5);
+
+	/* Resetting internal OHCI in USB OHCI space*/
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1508);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1508, tmp | 0x01);
+
+	/* Reseting OHCI dpll, it says the bit is for simulation */
+	tmp = gbus_read_reg32(REG_BASE_host_interface + 0x1700);
+	gbus_write_reg32(REG_BASE_host_interface + 0x1700, tmp | (1<<19));
+	mdelay(1);
+
+	/* Resetting ethernet interface */
+	gbus_write_reg32(REG_BASE_host_interface + 0x7018, 0);
+	gbus_write_reg32(REG_BASE_host_interface + 0x701c, 0);
+	gbus_write_reg32(REG_BASE_host_interface + 0x7000, 1);
+	for (i = 0; (i < 10) && (gbus_read_reg32(REG_BASE_host_interface + 0x7000) & 1); i++)
+		mdelay(1);
+
+	/* Resetting Video, MPEG0/MPEG1 blocks */ 
+	gbus_write_reg32(REG_BASE_display_block + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_display_block + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_mpeg_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_mpeg_engine_1 + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Transport demux block */
+	gbus_write_reg32(REG_BASE_demux_engine + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_demux_engine + G2L_RESET_CONTROL, 2);
+
+	/* Resetting Audio0/1, host interface blocks */
+	gbus_write_reg32(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 3);
+	gbus_write_reg32(REG_BASE_host_interface + G2L_RESET_CONTROL, 3);
+	udelay(1);
+	gbus_write_reg32(REG_BASE_audio_engine_0 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_audio_engine_1 + G2L_RESET_CONTROL, 2);
+	gbus_write_reg32(REG_BASE_host_interface + G2L_RESET_CONTROL, 2);
+#endif
+
+	/* restore remap registers to boot state */
+	for (i = 0; 
+#ifdef CONFIG_TANGO2
+		i < 5; 
+#elif defined(CONFIG_TANGO3)
+		i < 8; 
+#endif
+		i++) {
+		gbus_write_reg32(REG_BASE_cpu_block + CPU_remap + i * 4, em8xxx_remap_registers[i]);
+	}
+	iob();
+
+	/* Now to handle CPU side */
+
+#if defined(CONFIG_TANGO3)
+#ifndef CONFIG_TANGOX_FIXED_FREQUENCIES
+	/* Using watchdog to trigger reset here */
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0x80); 
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration, 0x1); /* Use XTAL_IN as source */
+
+	/* For ~100 usec delay */
+	gbus_write_reg32(REG_BASE_system_block + SYS_watchdog_counter, TANGOX_BASE_FREQUENCY / 10000);
+	gbus_write_reg8(REG_BASE_system_block + SYS_watchdog_configuration + 3, 0); /* Start counting */
+#else
+	/* Don't use watchdog to reboot */
+	printk("System rebooting ...\n");
+#endif
+#else
+	/* nowhere to  jump, everything is  in xload format,  lets ask
+	 * xpu to reboot */
+	base_addr = DMEM_BASE_audio_engine_0;
+
+	pB = (struct xrpc_block_header *)base_addr;
+	gbus_write_reg32((unsigned long)&pB->callerid, 0);
+	gbus_write_reg32((unsigned long)&pB->headerandblocksize,
+		    (sizeof(struct xrpc_block_header) + 63) & ~63);
+	gbus_write_reg32((unsigned long)&pB->xrpcid, XRPC_ID_REBOOT);
+
+	/* try to lock xrpc mutex for at most 1 sec */
+	for (loop = 0; loop < 1000; loop++) {
+		if (!gbus_read_reg32((RMuint32)XRPC_MUTEX))
+			break;
+		mdelay(1);
+	}
+	gbus_write_reg32(REG_BASE_cpu_block + LR_XPU_STAGE, (unsigned long)pB);
+
+	/* cross our fingers now */
+	gbus_write_reg32(REG_BASE_irq_handler_block + CPU_irq_softset,
+		    SOFT_IRQ_XRPC);
+#endif
+	while (1); /* wait forever */
+}
+
+void tangox_machine_halt(void)
+{
+	while (1); /* wait forever */
+}
+
+void tangox_machine_power_off(void)
+{
+	while (1);
+}
+
+union tangox_cycle_cnt_union {
+	u64 cycle64;
+	u32 cycle32[2];
+};
+static DEFINE_SPINLOCK(cycle_cnt_lock);
+static union tangox_cycle_cnt_union tangox_cycle_cnt;
+static u32 tangox_cycle_last = 0;
+
+static cycle_t tangox_read_cycles(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&cycle_cnt_lock, flags);
+	tangox_cycle_cnt.cycle32[0] = (u32)gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	if (tangox_cycle_last > tangox_cycle_cnt.cycle32[0])	
+		tangox_cycle_cnt.cycle32[1]++; /* low 32 overflowed, increase high 32 */
+
+	tangox_cycle_last = tangox_cycle_cnt.cycle32[0];
+	spin_unlock_irqrestore(&cycle_cnt_lock, flags);
+	return (cycle_t)tangox_cycle_cnt.cycle64;
+}
+
+void tangox_set_cycles(unsigned long cnt_low, unsigned long cnt_high, unsigned long cnt_last)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&cycle_cnt_lock, flags);
+	tangox_cycle_cnt.cycle32[0] = cnt_low;
+	tangox_cycle_cnt.cycle32[1] = cnt_high;
+	tangox_cycle_last = cnt_last;
+	spin_unlock_irqrestore(&cycle_cnt_lock, flags);
+}
+EXPORT_SYMBOL(tangox_set_cycles);
+
+void tangox_get_cycles(unsigned long *cnt_low, unsigned long *cnt_high, unsigned long *cnt_last)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&cycle_cnt_lock, flags);
+	*cnt_low = tangox_cycle_cnt.cycle32[0];
+	*cnt_high = tangox_cycle_cnt.cycle32[1];
+	*cnt_last = tangox_cycle_last;
+	spin_unlock_irqrestore(&cycle_cnt_lock, flags);
+}
+EXPORT_SYMBOL(tangox_get_cycles);
+
+struct clocksource clocksource_tangox = {
+	.name		= "TANGOX",
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+	.read		= tangox_read_cycles,
+};
+
+void __init plat_time_init(void)
+{
+	u64 temp;
+	u32 shift;
+
+	mips_hpt_frequency = em8xxx_cpu_frequency / 2;
+	/* Clear heart beat counter */
+	WR_CPU_REG32(LR_HB_CPU, 0);
+
+	/* Setup clock source from SYS_xtal_in_cnt */
+	clocksource_tangox.rating = em8xxx_cpu_frequency / 1000000;
+	tangox_cycle_cnt.cycle32[0] = tangox_cycle_last = (u32)gbus_read_reg32(REG_BASE_system_block + SYS_xtal_in_cnt);
+	tangox_cycle_cnt.cycle32[1] = 0;
+
+	/* Find a shift value */
+	for (shift = 32; shift > 0; shift--) {
+		temp = (u64) NSEC_PER_SEC << shift;
+		do_div(temp, TANGOX_BASE_FREQUENCY);
+		if ((temp >> 32) == 0)
+			break;
+	}
+	clocksource_tangox.shift = shift;
+	clocksource_tangox.mult = (u32)temp;
+
+	clocksource_register(&clocksource_tangox);
+}
+
+/*
+ * setup remap registers, we may need  to use ioremap() so we can't do
+ * this in plat_setup, this function is set as arch_initcall().
+ */
+static int __init tangox_remap_setup(void)
+{
+#if defined(CONFIG_TANGO2) && defined(CONFIG_TANGOX_USE_TLB_REMAP_DRAM1)
+	memcfg_t *m;
+#endif
+
+#if defined(CONFIG_TANGO2) 
+	/*
+	 * Program CPU_remap so we can see full 256MB space in KSEG0 /
+	 * KSEG1
+	 */
+#ifdef CONFIG_TANGOX_USE_TLB_REMAP_DRAM1
+	/*
+	 * Use TLB mapping to map the DRAM1 (size specified by memcfg)
+	 * into KSEG2
+	 */
+	m = (memcfg_t *)KSEG1ADDR(MEM_BASE_dram_controller_0 + FM_MEMCFG);
+
+	if (m->dram1_size) {
+		em86xx_tlb_dram1_map_size = ((m->dram1_size > 0x20000000) ? 
+			0x20000000 : m->dram1_size); /* Max. 512MB */
+		em86xx_tlb_dram1_map_base =
+			(unsigned long)ioremap(MEM_BASE_dram_controller_1,
+					       m->dram1_size);
+		printk("tangox: creating TLB mapping for 0x%08x at 0x%08lx, "
+		       "size 0x%08lx.\n", MEM_BASE_dram_controller_1,
+		       em86xx_tlb_dram1_map_base, em86xx_tlb_dram1_map_size);
+	} else {
+		printk("tangox: dram1 size is 0, _not_ creating mapping\n");
+	}
+#else
+	/*
+	 * Use remap strategy (CPU_remap3/4 for 128MB resolution)
+	 */
+	printk("tangox: creating CPU mapping for 0x%08x at 0x%08x, "
+	       "size 0x%08x.\n", MEM_BASE_dram_controller_1,
+	       CPU_remap3_address, 0x08000000);
+
+	/*
+	 * remap dram controller 1 at 0x08000000 -> 0x0fffffff (128MB)
+	 * so Linux can see it in KSEG[01]
+	 */
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap3,
+		    MEM_BASE_dram_controller_1);
+	gbus_write_reg32(REG_BASE_cpu_block + CPU_remap4,
+		    MEM_BASE_dram_controller_1 + 0x04000000);
+	iob();
+#endif
+#endif
+
+	return 0;
+}
+
+arch_initcall(tangox_remap_setup);
+
+extern int tangox_uart_enabled(int uart);
+extern int tangox_uart_baudrate(int uart);
+extern int tangox_uart_console_port(void);
+
+#ifdef CONFIG_SERIAL_8250
+struct tangox_uart_info {
+	int irq;
+	unsigned long base;
+};
+
+#if defined(CONFIG_TANGO3)
+static struct tangox_uart_info __initdata uinfo[3] = {
+	{ LOG2_CPU_UART0_INT, REG_BASE_cpu_block + CPU_UART0_base },
+	{ LOG2_CPU_UART1_INT, REG_BASE_cpu_block + CPU_UART1_base },
+	{ LOG2_CPU_UART2_INT, REG_BASE_cpu_block + CPU_UART2_base }, 
+};
+#else
+static struct tangox_uart_info __initdata uinfo[2] = {
+	{ LOG2_CPU_UART0_INT, REG_BASE_cpu_block + CPU_UART0_base },
+	{ LOG2_CPU_UART1_INT, REG_BASE_cpu_block + CPU_UART1_base },
+};
+#endif
+#endif
+
+void uart_init(int baud, int fifo);
+
+void __init plat_mem_setup(void)
+{
+#ifdef CONFIG_SERIAL_8250
+	int i, idx;
+	struct uart_port uart;
+	int console_port = tangox_uart_console_port();
+	int uinfo_size = sizeof(uinfo) / sizeof(uinfo[0]);
+#if defined(CONFIG_TANGO3)
+	unsigned long tangox_chip_id(void);
+	unsigned int chip_id = (tangox_chip_id() >> 16) & 0xfffe;
+#endif
+#endif
+
+	_machine_restart = tangox_machine_restart;
+	_machine_halt = tangox_machine_halt;
+	//_machine_power_off = tangox_machine_power_off;
+	pm_power_off = tangox_machine_power_off;
+
+#ifdef CONFIG_SERIAL_8250
+	/* Handle console first */
+	uart_init(tangox_uart_baudrate(console_port), 1);
+	memset(&uart, 0, sizeof (uart));
+	uart.line = 0;
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+	uart.uartclk = tangox_get_sysclock();
+#else
+#if defined(CONFIG_TANGO2)
+	uart.uartclk = TANGOX_BASE_FREQUENCY;
+#elif defined(CONFIG_TANGO3)
+	uart.uartclk = TANGO3_UART_FREQUENCY;
+#else
+#error Unsupported platform.
+#endif
+#endif
+	uart.irq = IRQ_CONTROLLER_IRQ_BASE + uinfo[console_port].irq;
+	uart.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+#ifdef CONFIG_TANGO3
+	if (((chip_id == 0x8656) || (chip_id == 0x8672)) && (console_port == 0))
+		uart.membase = (unsigned char *)(REG_BASE_system_block + 0x700);
+	else
+#endif
+		uart.membase = (unsigned char *)uinfo[console_port].base;
+	uart.iotype = UPIO_MEM;
+	uart.regshift = 2;
+
+	if (early_serial_setup(&uart))
+		printk("early_serial_setup failed\n");
+
+#ifdef CONFIG_TANGO3
+	if ((chip_id != 0x8652) && ((chip_id & 0xfff0) != 0x8670))
+		uinfo_size--;
+#endif
+
+	for (i = 0, idx = 1; (i < CONFIG_SERIAL_8250_NR_UARTS) && (i < uinfo_size); i++) {
+		if (console_port == i)
+			continue;
+
+		memset(&uart, 0, sizeof (uart));
+		uart.line = idx++;
+#ifdef CONFIG_TANGOX_UART_USE_SYSCLK
+		uart.uartclk = tangox_get_sysclock();
+#else
+#if defined(CONFIG_TANGO2)
+		uart.uartclk = TANGOX_BASE_FREQUENCY;
+#elif defined(CONFIG_TANGO3)
+		uart.uartclk = TANGO3_UART_FREQUENCY;
+#else
+#error Unsupported platform.
+#endif
+#endif
+		uart.irq = IRQ_CONTROLLER_IRQ_BASE + uinfo[i].irq;
+		uart.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST /* | UPF_SHARE_IRQ */;
+#ifdef CONFIG_TANGO3
+		if (((chip_id == 0x8656) || (chip_id == 0x8672)) && (i == 0))
+			uart.membase = (unsigned char *)(REG_BASE_system_block + 0x700);
+		else
+#endif
+			uart.membase = (unsigned char *)uinfo[i].base;
+		uart.iotype = UPIO_MEM;
+		uart.regshift = 2;
+
+		if (early_serial_setup(&uart))
+			printk("early_serial_setup failed\n");
+	}
+#endif
+
+	/*
+	 * set I/O /mem regions limit
+	 */
+	ioport_resource.start = 0;
+	ioport_resource.end = 0x80000000UL - 1;
+	iomem_resource.start = 0;
+	iomem_resource.end = 0x80000000UL - 1;
+}
+
+struct tangox_mutex_struct
+{
+	struct mutex mutex;
+	unsigned int lock_cnt;
+};
+
+static struct tangox_mutex_struct tangox_mutex[NUM_TANGOX_MUTEX];
+
+static int __init tangox_mutex_init(void)
+{
+	int i;
+	for (i = 0; i < NUM_TANGOX_MUTEX; i++) {
+		mutex_init(&tangox_mutex[i].mutex);
+		tangox_mutex[i].lock_cnt = 0;
+	}
+	return 0;
+}
+
+int tangox_mutex_lock(unsigned int idx)
+{
+	if (in_interrupt() || in_atomic())
+		return -1; /* not safe for context switching */
+	else if (unlikely(idx >= NUM_TANGOX_MUTEX))
+		return -1;
+
+	mutex_lock(&tangox_mutex[idx].mutex);
+	tangox_mutex[idx].lock_cnt++;
+	return 0;
+}
+
+int tangox_mutex_unlock(unsigned int idx)
+{
+	if ((idx < NUM_TANGOX_MUTEX) && (tangox_mutex[idx].lock_cnt > 0)) {
+		tangox_mutex[idx].lock_cnt--;
+		mutex_unlock(&tangox_mutex[idx].mutex);
+	}
+	return 0;
+}
+
+__initcall(tangox_mutex_init);
+EXPORT_SYMBOL(tangox_mutex_lock);
+EXPORT_SYMBOL(tangox_mutex_unlock);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/setup.h linux-2.6.29/arch/mips/tangox/setup.h
--- linux-2.6.29.ref/arch/mips/tangox/setup.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/setup.h	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,61 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * misc vars/func shared by platform setup code
+ */
+
+#ifndef __SETUP_H
+#define __SETUP_H
+
+#ifdef CONFIG_TANGO2
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#include <linux/interrupt.h>
+#include <asm/tango2/rmem86xxid.h>
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/emhwlib_dram.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#include <asm/tango2/tango2api.h>
+#include <asm/tango2/memcfg.h>
+#elif defined(CONFIG_TANGO3)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO3
+#include <linux/interrupt.h>
+#include <asm/tango3/rmem86xxid.h>
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/emhwlib_dram.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#include <asm/tango3/tango3api.h>
+#include <asm/tango3/hardware.h>
+#else
+#error "Unknown architecture"
+#endif
+
+/*
+ * in console.c
+ */
+void prom_console_register(void);
+
+/*
+ * in prom.c
+ */
+extern unsigned long em8xxx_cpu_frequency;
+extern unsigned long em8xxx_sys_frequency;
+#ifdef CONFIG_TANGO2
+extern unsigned long em8xxx_remap_registers[5];
+#elif defined(CONFIG_TANGO3)
+extern unsigned long em8xxx_remap_registers[9];
+#endif
+
+unsigned long tangox_get_cpuclock(void);
+unsigned long tangox_get_sysclock(void);
+
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/sha.c linux-2.6.29/arch/mips/tangox/sha.c
--- linux-2.6.29.ref/arch/mips/tangox/sha.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/sha.c	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,406 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mm.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <linux/version.h>
+#include <asm/scatterlist.h>
+#include <asm/byteorder.h>
+
+#include "sha.h"
+	
+#ifdef CONFIG_CRYPTO_SHA1
+#define SHA1_HMAC_BLOCK_SIZE	64
+#define SHA_WORKSPACE_WORDS 	80
+
+static void __init __sha1_init(struct sha1_ctx *sctx)
+{
+	static const struct sha1_ctx initstate = {
+	  0,
+	  { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 },
+	  { 0, }
+	};
+	*sctx = initstate;
+}
+
+static void __init __sha1_update(struct sha1_ctx *sctx, const u8 *data, unsigned int len)
+{
+	unsigned int partial, done;
+	const u8 *src;
+
+	partial = sctx->count & 0x3f;
+	sctx->count += len;
+	done = 0;
+	src = data;
+
+	if ((partial + len) > 63) {
+		u32 temp[SHA_WORKSPACE_WORDS];
+
+		if (partial) {
+			done = -partial;
+			memcpy(sctx->buffer + partial, data, done + 64);
+			src = sctx->buffer;
+		}
+
+		do {
+			sha_transform(sctx->state, src, temp);
+			done += 64;
+			src = data + done;
+		} while (done + 63 < len);
+
+		memset(temp, 0, sizeof(temp));
+		partial = 0;
+	}
+	memcpy(sctx->buffer + partial, src, len - done);
+}
+
+/* Add padding and return the message digest. */
+static void __init __sha1_final(struct sha1_ctx *sctx, u8 *out)
+{
+	__be32 *dst = (__be32 *)out;
+	u32 i, index, padlen;
+	__be64 bits;
+	static const u8 padding[64] = { 0x80, };
+
+	bits = cpu_to_be64(sctx->count << 3);
+
+	/* Pad out to 56 mod 64 */
+	index = sctx->count & 0x3f;
+	padlen = (index < 56) ? (56 - index) : ((64+56) - index);
+	__sha1_update(sctx, padding, padlen);
+
+	/* Append length */
+	__sha1_update(sctx, (const u8 *)&bits, sizeof(bits));
+
+	/* Store state in digest */
+	for (i = 0; i < 5; i++)
+		dst[i] = cpu_to_be32(sctx->state[i]);
+
+	/* Wipe context */
+	memset(sctx, 0, sizeof *sctx);
+}
+#endif /* CONFIG_CRYPTO_SHA1 */
+
+#ifdef CONFIG_CRYPTO_SHA1
+void __init sha1_full(u8 *digest, const u8 *src, u32 len)
+{
+	int i;
+	u8 tmp;
+
+	struct sha1_ctx ctx;
+
+	__sha1_init(&ctx);
+	__sha1_update(&ctx, src, len);
+	__sha1_final(&ctx, digest);
+
+	for (i = 0; i < SHA1_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA1_DIGEST_SIZE - i - 1];
+		digest[SHA1_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+
+#define SHA256_DIGEST_SIZE	32
+#define SHA256_HMAC_BLOCK_SIZE	64
+
+static inline u32 Ch(u32 x, u32 y, u32 z)
+{
+	return z ^ (x & (y ^ z));
+}
+
+static inline u32 Maj(u32 x, u32 y, u32 z)
+{
+	return (x & y) | (z & (x | y));
+}
+
+#define e0(x)       (ror32(x, 2) ^ ror32(x,13) ^ ror32(x,22))
+#define e1(x)       (ror32(x, 6) ^ ror32(x,11) ^ ror32(x,25))
+#define s0(x)       (ror32(x, 7) ^ ror32(x,18) ^ (x >> 3))
+#define s1(x)       (ror32(x,17) ^ ror32(x,19) ^ (x >> 10))
+
+#define H0         0x6a09e667
+#define H1         0xbb67ae85
+#define H2         0x3c6ef372
+#define H3         0xa54ff53a
+#define H4         0x510e527f
+#define H5         0x9b05688c
+#define H6         0x1f83d9ab
+#define H7         0x5be0cd19
+
+static inline void LOAD_OP(int I, u32 *W, const u8 *input)
+{
+	W[I] = __be32_to_cpu( ((__be32*)(input))[I] );
+}
+
+static inline void BLEND_OP(int I, u32 *W)
+{
+	W[I] = s1(W[I-2]) + W[I-7] + s0(W[I-15]) + W[I-16];
+}
+
+static void __init __sha256_transform(u32 *state, const u8 *input)
+{
+	u32 a, b, c, d, e, f, g, h, t1, t2;
+	u32 W[64];
+	int i;
+
+	/* load the input */
+	for (i = 0; i < 16; i++)
+		LOAD_OP(i, W, input);
+
+	/* now blend */
+	for (i = 16; i < 64; i++)
+		BLEND_OP(i, W);
+    
+	/* load the state into our registers */
+	a=state[0];  b=state[1];  c=state[2];  d=state[3];
+	e=state[4];  f=state[5];  g=state[6];  h=state[7];
+
+	/* now iterate */
+	t1 = h + e1(e) + Ch(e,f,g) + 0x428a2f98 + W[ 0];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x71374491 + W[ 1];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xb5c0fbcf + W[ 2];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xe9b5dba5 + W[ 3];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x3956c25b + W[ 4];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x59f111f1 + W[ 5];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x923f82a4 + W[ 6];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xab1c5ed5 + W[ 7];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xd807aa98 + W[ 8];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x12835b01 + W[ 9];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x243185be + W[10];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x550c7dc3 + W[11];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x72be5d74 + W[12];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x80deb1fe + W[13];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x9bdc06a7 + W[14];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xc19bf174 + W[15];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xe49b69c1 + W[16];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xefbe4786 + W[17];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x0fc19dc6 + W[18];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x240ca1cc + W[19];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x2de92c6f + W[20];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x4a7484aa + W[21];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x5cb0a9dc + W[22];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x76f988da + W[23];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x983e5152 + W[24];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xa831c66d + W[25];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xb00327c8 + W[26];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xbf597fc7 + W[27];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0xc6e00bf3 + W[28];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xd5a79147 + W[29];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x06ca6351 + W[30];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x14292967 + W[31];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x27b70a85 + W[32];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x2e1b2138 + W[33];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x4d2c6dfc + W[34];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x53380d13 + W[35];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x650a7354 + W[36];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x766a0abb + W[37];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x81c2c92e + W[38];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x92722c85 + W[39];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0xa2bfe8a1 + W[40];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0xa81a664b + W[41];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0xc24b8b70 + W[42];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0xc76c51a3 + W[43];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0xd192e819 + W[44];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xd6990624 + W[45];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0xf40e3585 + W[46];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x106aa070 + W[47];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x19a4c116 + W[48];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x1e376c08 + W[49];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x2748774c + W[50];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x34b0bcb5 + W[51];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x391c0cb3 + W[52];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0x4ed8aa4a + W[53];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0x5b9cca4f + W[54];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0x682e6ff3 + W[55];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	t1 = h + e1(e) + Ch(e,f,g) + 0x748f82ee + W[56];
+	t2 = e0(a) + Maj(a,b,c);    d+=t1;    h=t1+t2;
+	t1 = g + e1(d) + Ch(d,e,f) + 0x78a5636f + W[57];
+	t2 = e0(h) + Maj(h,a,b);    c+=t1;    g=t1+t2;
+	t1 = f + e1(c) + Ch(c,d,e) + 0x84c87814 + W[58];
+	t2 = e0(g) + Maj(g,h,a);    b+=t1;    f=t1+t2;
+	t1 = e + e1(b) + Ch(b,c,d) + 0x8cc70208 + W[59];
+	t2 = e0(f) + Maj(f,g,h);    a+=t1;    e=t1+t2;
+	t1 = d + e1(a) + Ch(a,b,c) + 0x90befffa + W[60];
+	t2 = e0(e) + Maj(e,f,g);    h+=t1;    d=t1+t2;
+	t1 = c + e1(h) + Ch(h,a,b) + 0xa4506ceb + W[61];
+	t2 = e0(d) + Maj(d,e,f);    g+=t1;    c=t1+t2;
+	t1 = b + e1(g) + Ch(g,h,a) + 0xbef9a3f7 + W[62];
+	t2 = e0(c) + Maj(c,d,e);    f+=t1;    b=t1+t2;
+	t1 = a + e1(f) + Ch(f,g,h) + 0xc67178f2 + W[63];
+	t2 = e0(b) + Maj(b,c,d);    e+=t1;    a=t1+t2;
+
+	state[0] += a; state[1] += b; state[2] += c; state[3] += d;
+	state[4] += e; state[5] += f; state[6] += g; state[7] += h;
+
+	/* clear any sensitive info... */
+	a = b = c = d = e = f = g = h = t1 = t2 = 0;
+	memset(W, 0, 64 * sizeof(u32));
+}
+
+static void __init __sha256_init(struct sha256_ctx *sctx)
+{
+	sctx->state[0] = H0;
+	sctx->state[1] = H1;
+	sctx->state[2] = H2;
+	sctx->state[3] = H3;
+	sctx->state[4] = H4;
+	sctx->state[5] = H5;
+	sctx->state[6] = H6;
+	sctx->state[7] = H7;
+	sctx->count[0] = sctx->count[1] = 0;
+}
+
+static void __init __sha256_update(struct sha256_ctx *sctx, const u8 *data, unsigned int len)
+{
+	unsigned int i, index, part_len;
+
+	/* Compute number of bytes mod 128 */
+	index = (unsigned int)((sctx->count[0] >> 3) & 0x3f);
+
+	/* Update number of bits */
+	if ((sctx->count[0] += (len << 3)) < (len << 3)) {
+		sctx->count[1]++;
+		sctx->count[1] += (len >> 29);
+	}
+
+	part_len = 64 - index;
+
+	/* Transform as many times as possible. */
+	if (len >= part_len) {
+		memcpy(&sctx->buf[index], data, part_len);
+		__sha256_transform(sctx->state, sctx->buf);
+
+		for (i = part_len; i + 63 < len; i += 64)
+			__sha256_transform(sctx->state, &data[i]);
+		index = 0;
+	} else {
+		i = 0;
+	}
+	
+	/* Buffer remaining input */
+	memcpy(&sctx->buf[index], &data[i], len-i);
+}
+
+static void __init __sha256_final(struct sha256_ctx *sctx, u8 *out)
+{
+	__be32 *dst = (__be32 *)out;
+	__be32 bits[2];
+	unsigned int index, pad_len;
+	int i;
+	static const u8 padding[64] = { 0x80, };
+
+	/* Save number of bits */
+	bits[1] = cpu_to_be32(sctx->count[0]);
+	bits[0] = cpu_to_be32(sctx->count[1]);
+
+	/* Pad out to 56 mod 64. */
+	index = (sctx->count[0] >> 3) & 0x3f;
+	pad_len = (index < 56) ? (56 - index) : ((64+56) - index);
+	__sha256_update(sctx, padding, pad_len);
+
+	/* Append length (before padding) */
+	__sha256_update(sctx, (const u8 *)bits, sizeof(bits));
+
+	/* Store state in digest */
+	for (i = 0; i < 8; i++)
+		dst[i] = cpu_to_be32(sctx->state[i]);
+
+	/* Zeroize sensitive information. */
+	memset(sctx, 0, sizeof(*sctx));
+}
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+void __init sha256_full(u8 *digest, const u8 *src, u32 len)
+{
+	int i;
+	u8 tmp;
+	struct sha256_ctx ctx;
+
+	__sha256_init(&ctx);
+	__sha256_update(&ctx, src, len);
+	__sha256_final(&ctx, digest);
+
+	for (i = 0; i < SHA256_DIGEST_SIZE / 2; i++) {
+		tmp = digest[i];
+		digest[i] = digest[SHA256_DIGEST_SIZE - i - 1];
+		digest[SHA256_DIGEST_SIZE - i - 1] = tmp;
+	}
+}
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/sha.h linux-2.6.29/arch/mips/tangox/sha.h
--- linux-2.6.29.ref/arch/mips/tangox/sha.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/sha.h	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,35 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#ifndef __SHA_H__
+#define __SHA_H__
+
+#ifdef CONFIG_CRYPTO_SHA1
+#define SHA1_DIGEST_SIZE        20
+
+struct sha1_ctx {
+	u64 count;
+        u32 state[5];
+        u8 buffer[64];
+};
+#endif
+
+#ifdef CONFIG_CRYPTO_SHA256
+#define SHA256_DIGEST_SIZE      32
+
+struct sha256_ctx {
+	u32 count[2];
+        u32 state[8];
+        u8 buf[128];
+};
+#endif
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/xenv.c linux-2.6.29/arch/mips/tangox/xenv.c
--- linux-2.6.29.ref/arch/mips/tangox/xenv.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/xenv.c	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,281 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+#include "setup.h"
+#include "xenv.h"
+#include "sha.h"
+
+#include <linux/module.h>
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#endif
+
+#if 1
+# define DPRINTK(fmt, args...)	printk(KERN_DEBUG "xenv: " fmt, ## args)
+#else
+# define DPRINTK(fmt, args...)
+#endif
+
+#if defined(CONFIG_TANGO2)
+#define XENV_DIGEST_SIZE   SHA1_DIGEST_SIZE
+void sha1_full(u8 *digest, const u8 *src, u32 len);
+#elif defined(CONFIG_TANGO3)
+#define XENV_DIGEST_SIZE   SHA256_DIGEST_SIZE
+void sha256_full(u8 *digest, const u8 *src, u32 len);
+#endif
+
+#define XENV_HDR_SIZE      (XENV_DIGEST_SIZE + 4)
+#define REC_SIZE(x)	   ((((u16)x[0] & 0xff) << 8) | ((u16)x[1] & 0xff))
+#define REC_ATTR(x)	   ((x[0] & 0xff) >> 4)
+
+#define xos_strlen(x)	   strlen(x)
+#define xos_strcmp(x,y)	   strcmp(x,y)
+#define xos_memcpy(x,y,z)  memcpy(x,y,z)
+
+void __init xenv_digest_full(u8 *digest, const u8 *src, u32 len)
+{
+#if defined(CONFIG_TANGO2)
+	sha1_full(digest, src, len);
+#elif defined(CONFIG_TANGO3)
+	sha256_full(digest, src, len);
+#endif
+}
+
+#if 0
+static void dump_digest(const u8 *digest)
+{
+	int i;
+	printk("Dump digest\n");
+	for (i = 0; i < XENV_DIGEST_SIZE; i++, digest++)
+		printk("%02x ", *digest);
+	printk("\n");
+}
+#endif
+
+/*
+ * check for valid XENV at given address
+ */
+int __init xenv_isvalid(u32 *base, u32 maxsize)
+{
+	u32 env_size = base[0];
+	u32 hash[XENV_DIGEST_SIZE/4];
+
+	if ((XENV_HDR_SIZE <= env_size) && (env_size <= maxsize)) {
+		memset(hash, 0, sizeof (hash));
+		xenv_digest_full((u8 *)hash, (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+		if (memcmp((const u8 *)(base + 1), hash, XENV_DIGEST_SIZE) != 0) {
+			DPRINTK("corrupted\n");
+			return -1;
+		}
+		/* valid xenv ! */
+		return env_size;
+	}
+	DPRINTK("runaway %d\n", env_size);
+	return -1;
+}
+
+int __init xenv_foreach(u32 *xenv_base, u32 size,
+			void (*cb)(char *recordname, void *data, u32 datasize))
+{
+	int i;
+	char *base = (char *)xenv_base;
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	/* loop on each record name */
+	while (i < size) {
+		u16 rec_size;
+		char *recordname;
+		void *data;
+		u32 key_len, data_len;
+
+		rec_size=((base[i]&0xf)<<8) + (((u16)base[i+1])&0xff);
+		recordname=(char *)(base+i+2);
+		key_len=strnlen(recordname, size);
+		data = recordname + key_len + 1;
+		data_len = rec_size - 2 - key_len - 1;
+
+		cb(recordname, data, data_len);
+		i += rec_size;
+	}
+
+	return -1;
+}
+
+#if defined(CONFIG_TANGO3)
+/* Use this to set xenv to lrrw */
+static int __init xenv_lookup(RMuint32 *base,RMuint32 size,RMascii *recordname)
+{
+	RMascii *p;
+	int i;
+	int env_size;
+	
+	env_size=xenv_isvalid((u32 *)base,size);
+	
+	if (env_size<0) 
+		return -2;
+	
+	// RMDBGLOG((LOCALDBG, "[%s]\n",recordname));
+	
+	p=(RMascii *)base;
+	i=XENV_HDR_SIZE; 			// jump over header
+	
+	while(i<env_size){
+		RMuint16 rec_size=((p[i]&0xf)<<8) + (((RMuint16)p[i+1])&0xff);
+
+		if (!xos_strcmp(recordname, p+i+2)) 
+			return i;
+		
+		i+=rec_size;
+	}
+	
+	return -1;
+}
+
+/* Use this to get xenv to lrrw/lrro */
+int __init xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize)
+{
+	RMascii *p = (RMascii *)base;
+	RMuint32 data_len;
+	RMuint32 key_len;
+	RMuint32 env_size;
+	
+	int i;	
+	
+	env_size=base[0];
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -2 /* RM_ERROR */;
+	if(i==-1) 
+		return -1 /* RM_NOT_FOUND */;
+
+	// else we found the record
+	key_len=xos_strlen(recordname);
+	data_len=((p[i] & 0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+	data_len-=2+key_len+1;
+	
+	if(data_len>*datasize) {
+		*datasize=data_len;
+
+		// RMDBGLOG((ENABLE,"cannot store result\n"));
+		return -3 /* RM_INSUFFICIENT_SIZE */;
+	}
+	
+	*datasize=data_len;
+	xos_memcpy(dst, p+i+2+key_len+1, data_len);
+
+	// RMDBGLOG((LOCALDBG, "found [%s], length %d\n",recordname,*datasize));
+
+	return 0 /* RM_OK */;
+}
+
+int __init xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize)
+{
+	RMascii *p;
+	RMuint32 env_size;
+	RMuint32 rec_attr;
+	RMuint32 rec_size;
+	RMuint32 key_len;
+	int i;
+
+	// RMDBGLOG((LOCALDBG, "[%s], length %d\n", recordname,datasize));
+	
+	p=(RMascii *)base;
+	i = xenv_lookup((RMuint32 *)base, size, recordname);
+	if(i==-2) 
+		return -1 /* RM_ERROR */;
+	env_size=base[0];
+
+	if(i>=0) {
+		// RMDBGLOG((LOCALDBG, "deleting record\n"));
+		
+		rec_attr=p[i]>>4;
+		rec_size=((p[i]&0xf)<<8) + (((RMuint32)p[i+1])&0xff);
+			
+#if 0
+		if ((rec_attr==XENV_ATTR_RO)&&src) {
+			// RMDBGLOG((ENABLE,"wanna change ro record\n"));
+			return RM_INVALIDMODE;
+		}
+		
+		if (rec_attr==XENV_ATTR_OTP) {
+			// RMDBGLOG((ENABLE,"wanna change/clear otp record\n"));
+			return RM_INVALIDMODE;
+		}
+#endif
+
+		// delete the record. Supposes memcpy is implemented increasing.
+		xos_memcpy(p+i, p+i+rec_size, env_size-(i+rec_size));
+		env_size-=rec_size;
+	}
+		
+	// add the record at the end if needed.
+	if(src) {
+		i=env_size;
+		key_len=xos_strlen(recordname);
+		rec_size=2+key_len+1+datasize;
+
+		if((i+rec_size)>=size)
+			return -3 /* RM_INSUFFICIENT_SIZE */;
+		
+		p[i]=((attr&0xf)<<4) | ((rec_size>>8)&0xf);
+		p[i+1]=rec_size&0xff;
+		
+		xos_memcpy(p+i+2, recordname, key_len+1);
+		xos_memcpy(p+i+2+key_len+1, src, datasize);
+		
+		env_size+=rec_size;
+	}
+	
+	base[0]=env_size;
+	//full_sha256(base+1,(const RMuint8 *)(base+9),env_size-36,0);
+	xenv_digest_full((u8 *)(base+1), (const u8 *)(base + (XENV_HDR_SIZE / 4)), env_size - XENV_HDR_SIZE);
+
+	return 0 /* RM_OK */;
+}
+#endif
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+void __init xenv_dump(u32 *xenv_base, u32 size)
+{
+	int i;
+	u32 records = 0;
+	char *base = (char *)xenv_base;
+
+	printk("@%p\n", base);
+
+	/* jump over first header */
+	i = XENV_HDR_SIZE;
+
+	while (i < size){
+		u8 rec_attr;
+		u16 rec_size;
+		char *recordname, *x;
+		u32 key_len;
+
+		rec_attr=(base[i]>>4)&0xf;
+		rec_size=((base[i]&0xf)<<8) + (((u16)base[i+1])&0xff);
+		recordname=(char *)(base+i+2);
+		key_len=strnlen(recordname, size);
+
+		printk("(0x%02x) [%s] =", rec_attr, recordname);
+		for (x = recordname + key_len + 1;
+		     x < recordname + rec_size - 2; x++)
+			printk(" %02x", (u8)*x);
+		printk(" .\n");
+
+		records++;
+		i += rec_size;
+	}
+
+	printk("%d records, %d bytes\n\n", records, size);
+}
+#endif
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/xenv_config.c linux-2.6.29/arch/mips/tangox/xenv_config.c
--- linux-2.6.29.ref/arch/mips/tangox/xenv_config.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/xenv_config.c	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,848 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2008
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/*
+ * Check and  read full xenv config  at boot if valid,  else will stop
+ * boot process or use failsafe values.
+ */
+
+#include "setup.h"
+#include "xenv.h"
+#include "xenvkeys.h"
+
+#include <linux/module.h>
+#include <asm/bootinfo.h>
+
+/*
+ * use CPU_remap1 to access XENV content
+ */
+#define TMP_REMAPPED_REG   CPU_remap1
+#define TMP_REMAPPED_BASE  CPU_remap1_address 
+#define TMP_REMAPPED_SIZE  0x00010000
+#define TMP_REMAPPED_MASK  ~(TMP_REMAPPED_SIZE-1)
+
+/*
+ * cached values of xenv content
+ */
+#define XENV_MAX_FLASH_PARTITIONS   16
+
+typedef union
+{
+	u64 uint64[1];
+	u32 uint32[2];
+	u16 uint16[4];
+	u8 uint8[8];
+} uint_union;
+
+/*
+ * default is  to have one  partition on each  flash at offset  0 that
+ * span all the flash. If CONFIG_TANGOX_XENV_DEF_CSx_SIZE is set to 0,
+ * cs will be ignored.
+ */
+#ifdef CONFIG_TANGOX_XENV_READ_SAFE
+/* The data will be filled from XENV later */
+static uint_union cs_flash_size[4] = { { { 0 } }, { { 0 } }, { { 0 } }, { { 0 } }, };
+static uint_union flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = { { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, };
+static u32 enabled_devices = 0;
+static u32 uart_baudrate = 0;
+static u32 uart_baudrates[3] = { 0, 0, 0 };
+static u32 uart_used_ports = 0;
+static u32 pcidev_irq_route[4] = { 0, 0, 0, 0 };
+static u32 uart_console_port = 0;
+#else
+static uint_union cs_flash_size[4] = {
+	{ { CONFIG_TANGOX_XENV_DEF_CS0_SIZE } },
+	{ { CONFIG_TANGOX_XENV_DEF_CS1_SIZE } },
+	{ { CONFIG_TANGOX_XENV_DEF_CS2_SIZE } },
+	{ { CONFIG_TANGOX_XENV_DEF_CS3_SIZE } },
+};
+
+static uint_union flash_parts_size[4][XENV_MAX_FLASH_PARTITIONS] = {
+	{ { { CONFIG_TANGOX_XENV_DEF_CS0_SIZE } } },
+	{ { { CONFIG_TANGOX_XENV_DEF_CS1_SIZE } } },
+	{ { { CONFIG_TANGOX_XENV_DEF_CS2_SIZE } } },
+	{ { { CONFIG_TANGOX_XENV_DEF_CS3_SIZE } } },
+};
+
+static u32 enabled_devices =
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID1 << PCI1_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID2 << PCI2_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID3 << PCI3_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4 
+	(CONFIG_TANGOX_XENV_DEF_PCI_ID4 << PCI4_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ENET 
+	(CONFIG_TANGOX_XENV_DEF_ENET << ETHERNET_SHIFT) |
+#else
+	0 | 
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_FIP 
+	(CONFIG_TANGOX_XENV_DEF_FIP << FIP_SHIFT) |
+#else 
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CM 
+	(CONFIG_TANGOX_XENV_DEF_I2CM << I2CM_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_I2CS 
+	(CONFIG_TANGOX_XENV_DEF_I2CS << I2CS_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_BMIDE 
+	(CONFIG_TANGOX_XENV_DEF_BMIDE << BMIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_ISAIDE 
+	(CONFIG_TANGOX_XENV_DEF_ISAIDE << ISAIDE_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_IR 
+	(CONFIG_TANGOX_XENV_DEF_IR << IR_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCIHOST
+	(CONFIG_TANGOX_XENV_DEF_PCIHOST << PCIHOST_SHIFT) |
+#else
+	0 |
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_USB 
+	(CONFIG_TANGOX_XENV_DEF_USB << USB_SHIFT)
+#else
+	0
+#endif
+	;
+
+static u32 uart_baudrate = CONFIG_TANGOX_XENV_DEF_BAUDRATE;
+static u32 uart_baudrates[3] = { CONFIG_TANGOX_XENV_DEF_BAUDRATE, CONFIG_TANGOX_XENV_DEF_BAUDRATE, CONFIG_TANGOX_XENV_DEF_BAUDRATE, };
+
+static u32 uart_used_ports = 
+#ifdef CONFIG_TANGOX_XENV_DEF_UART0
+		1 +
+#else
+		0 +
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_UART1
+		1;
+#else
+		0;
+#endif
+
+static u32 pcidev_irq_route[4] = { 
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID1_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID2_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ
+	CONFIG_TANGOX_XENV_DEF_PCI_ID3_IRQ,
+#else
+	0,
+#endif
+#ifdef CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+	CONFIG_TANGOX_XENV_DEF_PCI_ID4_IRQ 
+#else
+	0
+#endif
+};
+
+static u32 uart_console_port = CONFIG_TANGOX_XENV_DEF_CONSOLE_UART_PORT;
+#endif
+
+static u32 cs_flash_parts[4] = { 0, 0, 0, 0 };
+static uint_union flash_parts_offset[4][XENV_MAX_FLASH_PARTITIONS] = { { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, { { { 0 } } }, };
+static u32 scard_off_pin = 0;
+static u32 scard_cmd_pin = 0;
+static u32 scard_5v_pin = 0;
+#if defined(CONFIG_TANGO3)
+static u32 scard1_off_pin = 0;
+static u32 scard1_cmd_pin = 0;
+static u32 scard1_5v_pin = 0;
+static u32 sata_channel_cfg = 0;
+static u32 cs_rsvd_pblk[4] = { 0, 0, 0, 0 };
+#endif
+static u32 isaide_timing_slot = 0;
+static u32 isaide_irq = 0;
+
+static u32 xenv_gbus_addr = 0;
+
+/* mac address to use if xenv is not readable  */
+static const u8 def_mac_address[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x01 };
+static u8 mac_address[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x02 };
+#if defined(CONFIG_TANGO3)
+static u8 mac_address1[6] = { 0x48, 0x4a, 0xe5, 0x00, 0x00, 0x03 };
+#endif
+
+/* for power saving (e.g. low frequency) */
+#ifdef CONFIG_TANGO2
+static u32 ps_pll3=0, ps_pll2=0, ps_pll1=0, ps_pll0=0, ps_mux=0, ps_d0cfg=0, ps_d1cfg=0, ps_d0delay=0, ps_d1delay=0;
+static u32 standby_pll3=0, standby_pll2=0, standby_pll1=0, standby_pll0=0, standby_mux=0, standby_d0cfg=0, standby_d1cfg=0, standby_d0delay=0, standby_d1delay=0;
+static u32 standby_gpiodir = 0, standby_gpiodata = 0;
+#endif
+
+#if defined(CONFIG_TANGO3)
+#define MT3_HS_SIZE	140	/* sizeof(struct mt3_hw_settings_t) */
+static u32 ps_pll2=0, ps_pll0=0, ps_mt3_hs[MT3_HS_SIZE/sizeof(u32)];
+static u32 standby_pll2=0, standby_pll0=0, standby_mt3_hs[MT3_HS_SIZE/sizeof(u32)];
+static u32 standby_gpiodir = 0, standby_gpiodata = 0;
+#endif
+
+static char xenv_cmdline[CL_SIZE] = { 0 };
+
+#if defined(CONFIG_TANGO3)
+static unsigned long zxenv[MAX_XENV_SIZE/sizeof(unsigned long)] __initdata = { 0 };
+#endif
+
+#ifdef CONFIG_TANGOX_XENV_READ
+/*
+ * called for each entry found in xenv
+ */
+void __init xenv_val_cb(char *recordname, void *data, u32 datasize)
+{
+	char buf[64];
+	int i;
+	static const char *h32str = "_hi";
+
+#define CHECK_AND_STORE(_key, _reqlen, _var)				\
+	if (!strcmp(_key, recordname) && datasize <= _reqlen)	{	\
+		memcpy(&_var, data, _reqlen);				\
+		return;							\
+	}
+#define CHECK_AND_STORE1(_key, _reqlen, _var)				\
+	if (!strcmp(_key, recordname) && datasize <= _reqlen)	{	\
+		memset(&_var, 0, _reqlen);				\
+		memcpy(&_var, data, datasize);				\
+		return;							\
+	}
+
+	CHECK_AND_STORE(XENV_KEY_ENABLED_DEVICES, 4, enabled_devices);
+	CHECK_AND_STORE(XENV_KEY_DEF_BAUDRATE, 4, uart_baudrate);
+	CHECK_AND_STORE(XENV_KEY_UART_USED_PORTS, 4, uart_used_ports);
+	CHECK_AND_STORE(XENV_KEY_CONSOLE_UART_PORT, 4, uart_console_port);
+
+	if (uart_console_port == 0) /* for backward compatibility */
+		uart_used_ports |= 1;
+
+	for (i = 0; i < 3; i++) {
+		sprintf(buf, XENV_KEYS_UART_BAUDRATE, i);
+		CHECK_AND_STORE(buf, 4, uart_baudrates[i]);
+	}
+
+	if (uart_baudrate == 0)
+		uart_baudrate = 115200; /* default 115200 */
+	if (uart_baudrates[0] == 0)
+		uart_baudrates[0] = uart_baudrate;
+	if (uart_baudrates[1] == 0)
+		uart_baudrates[1] = uart_baudrate;
+	if (uart_baudrates[2] == 0)
+		uart_baudrates[2] = uart_baudrate;
+
+	for (i = 1; i < 5; i++) {
+		sprintf(buf, XENV_KEYS_PCI_IRQ_ROUTE, i);
+		CHECK_AND_STORE(buf, 4, pcidev_irq_route[i - 1]);
+	}
+
+	CHECK_AND_STORE(XENV_KEY_SCARD_OFF, 4, scard_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_5V, 4, scard_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD_CMD, 4, scard_cmd_pin);
+#if defined(CONFIG_TANGO3)
+	CHECK_AND_STORE(XENV_KEY_SCARD1_OFF, 4, scard1_off_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_5V, 4, scard1_5v_pin);
+	CHECK_AND_STORE(XENV_KEY_SCARD1_CMD, 4, scard1_cmd_pin);
+	CHECK_AND_STORE(XENV_KEY_SATA_CHANNEL_CFG, 4, sata_channel_cfg);
+#endif
+
+	for (i = 0; i < 4; i++) {
+		int j;
+
+		sprintf(buf, XENV_KEYS_CS_SIZE, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_size[i].uint32[0]);
+		strcat(buf, h32str);
+		CHECK_AND_STORE(buf, 4, cs_flash_size[i].uint32[1]);
+
+		sprintf(buf, XENV_KEYS_CS_PARTS, i);
+		CHECK_AND_STORE(buf, 4, cs_flash_parts[i]);
+
+#if defined(CONFIG_TANGO3)
+		sprintf(buf, XENV_KEYS_CS_RSVD_PBLK, i);
+		CHECK_AND_STORE(buf, 4, cs_rsvd_pblk[i]);
+#endif
+
+		for (j = 1; j < XENV_MAX_FLASH_PARTITIONS; j++) {
+
+			sprintf(buf, XENV_KEYS_CS_PART_SIZE, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_size[i][j - 1].uint32[0]);
+			strcat(buf, h32str);
+			CHECK_AND_STORE(buf, 4, flash_parts_size[i][j - 1].uint32[1]);
+
+			sprintf(buf, XENV_KEYS_CS_PART_OFFSET, i, j);
+			CHECK_AND_STORE(buf, 4, flash_parts_offset[i][j - 1].uint32[0]);
+			strcat(buf, h32str);
+			CHECK_AND_STORE(buf, 4, flash_parts_offset[i][j - 1].uint32[1]);
+		}
+	}
+
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_IRQ_ROUTE, 4, isaide_irq);
+	CHECK_AND_STORE(XENV_KEY_ISAIDE_TIMING_SLOT, 4, isaide_timing_slot);
+
+	if (!strcmp(recordname, XENV_KEY_LINUX_CMD) &&
+	    datasize <= sizeof (xenv_cmdline) - 1) {
+		memcpy(xenv_cmdline, data, datasize);
+		xenv_cmdline[datasize] = 0;
+	}
+
+#ifdef CONFIG_TANGO2
+	CHECK_AND_STORE(XENV_KEY_PS_PLL3, 4, ps_pll3);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL2, 4, ps_pll2);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL1, 4, ps_pll1);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL0, 4, ps_pll0);
+	CHECK_AND_STORE(XENV_KEY_PS_MUX, 4, ps_mux);
+	CHECK_AND_STORE(XENV_KEY_PS_D0CFG, 4, ps_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D1CFG, 4, ps_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_PS_D0DELAY, 4, ps_d0delay);
+	CHECK_AND_STORE(XENV_KEY_PS_D1DELAY, 4, ps_d1delay);
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL3, 4, standby_pll3);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL2, 4, standby_pll2);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL1, 4, standby_pll1);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL0, 4, standby_pll0);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_MUX, 4, standby_mux);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0CFG, 4, standby_d0cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1CFG, 4, standby_d1cfg);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D0DELAY, 4, standby_d0delay);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_D1DELAY, 4, standby_d1delay);
+#endif
+
+#if defined(CONFIG_TANGO3)
+	CHECK_AND_STORE(XENV_KEY_PS_PLL2, 4, ps_pll2);
+	CHECK_AND_STORE(XENV_KEY_PS_PLL0, 4, ps_pll0);
+	CHECK_AND_STORE1(XENV_KEY_PS_MT3_HS, MT3_HS_SIZE, ps_mt3_hs[0]);
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL2, 4, standby_pll2);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_PLL0, 4, standby_pll0);
+	CHECK_AND_STORE1(XENV_KEY_STANDBY_MT3_HS, MT3_HS_SIZE, standby_mt3_hs[0]);
+#endif
+
+	CHECK_AND_STORE(XENV_KEY_STANDBY_GPIODIR, 4, standby_gpiodir);
+	CHECK_AND_STORE(XENV_KEY_STANDBY_GPIODATA, 4, standby_gpiodata);
+}
+
+/*
+ * try to read config from XENV
+ */
+static int __init xenv_read_content(void)
+{
+	unsigned long xenv_addr, old_remap;
+	int xenv_size, ret = 0;
+	uint32_t mac_lo, mac_hi;
+	/*
+	 * fetch XENV address
+	 */
+#if defined(CONFIG_TANGO3)
+	unsigned int size, tmp, copy_size;
+	unsigned char *xenv_blk = (unsigned char *)zxenv;
+	xenv_gbus_addr = xenv_addr = gbus_read_reg32(REG_BASE_cpu_block + LR_ZBOOTXENV_LOCATION);
+#else
+	xenv_gbus_addr = xenv_addr = gbus_read_reg32(REG_BASE_cpu_block + LR_XENV_LOCATION);
+#endif
+	if (!xenv_addr)
+		return 1;
+
+	/*
+	 * got the xenv address in  gbus form, now convert it in remap
+	 * form so we can access it
+	 */
+	old_remap = gbus_read_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG);
+	gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, xenv_addr & TMP_REMAPPED_MASK);
+	iob();
+	xenv_addr = KSEG1ADDR(TMP_REMAPPED_BASE) + (xenv_addr & (TMP_REMAPPED_SIZE-1));
+
+#if defined(CONFIG_TANGO3)
+	/*
+	 * may need to make a copy of XENV (if it acrosses remap boundary)
+	 */
+	xenv_size = *((int *)xenv_addr);
+	copy_size = TMP_REMAPPED_SIZE - (xenv_gbus_addr & (TMP_REMAPPED_SIZE-1));
+	if (xenv_size >= MAX_XENV_SIZE) { /* XENV too big */
+		ret = 1;
+		goto done;
+	} else if (copy_size < xenv_size) { /* across remap boundary */
+		memcpy(xenv_blk, (void *)xenv_addr, copy_size);
+		gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, (xenv_gbus_addr + TMP_REMAPPED_SIZE) & TMP_REMAPPED_MASK);
+		iob();
+		memcpy(xenv_blk + copy_size, (void *)KSEG1ADDR(TMP_REMAPPED_BASE), xenv_size - copy_size);
+		xenv_addr = (unsigned long)xenv_blk; /* use the copy */
+	}
+#endif
+
+	/*
+	 * check xenv sanity
+	 */
+	xenv_size = xenv_isvalid((u32 *)xenv_addr, MAX_XENV_SIZE);
+	if (xenv_size < 0) {
+		xenv_gbus_addr = xenv_addr = 0;
+		ret = 1;
+		goto done;
+	}
+
+#ifdef CONFIG_TANGOX_XENV_DUMP
+	xenv_dump((u32 *)xenv_addr, xenv_size);
+#endif
+
+	/*
+	 * ok, we can start to load each wanted value
+	 */
+	xenv_foreach((u32 *)xenv_addr, xenv_size, xenv_val_cb);
+
+	/*
+	 * load remaining values
+	 */
+#if defined(CONFIG_TANGO3)
+	/* Getting information from LR_XENV2_RW */
+	mac_hi = mac_lo = 0x0; size = sizeof(unsigned int);
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int)))
+		mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+
+	mac_hi = mac_lo = 0x0; size = sizeof(unsigned int);
+	if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACL, &tmp, &size) == 0) && (size == sizeof(unsigned int))) {
+		mac_lo = tmp;
+		if ((xenv_get((void *)KSEG1ADDR(REG_BASE_cpu_block + LR_XENV2_RW), MAX_LR_XENV2_RW, XENV_LRRW_ETH1_MACH, &tmp, &size) == 0) && (size == sizeof(unsigned int)))
+			mac_hi = tmp;
+	}
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address1, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address1 + 2, &mac_lo, 4);
+#else
+	mac_hi = gbus_read_reg32(REG_BASE_cpu_block + LR_ETH_MAC_HI);
+	mac_lo = gbus_read_reg32(REG_BASE_cpu_block + LR_ETH_MAC_LO);
+	mac_hi = cpu_to_be32(mac_hi);
+	mac_lo = cpu_to_be32(mac_lo);
+	memcpy(mac_address, (u8 *)&mac_hi + 2, 2);
+	memcpy(mac_address + 2, &mac_lo, 4);
+#endif
+
+done:
+	gbus_write_reg32(REG_BASE_cpu_block + TMP_REMAPPED_REG, old_remap);
+	iob();
+
+	return ret;
+}
+#endif
+
+/*
+ * load default values and try to fetch xenv content
+ */
+int __init xenv_config(void)
+{
+#ifndef CONFIG_TANGOX_XENV_READ
+	/* will use default values */
+	return 0;
+#else
+	/*
+	 * try to load XENV content
+	 */
+	if (xenv_read_content() == 0) {
+		/* ok */
+		return 0;
+	}
+
+#ifndef CONFIG_TANGOX_XENV_READ_SAFE
+
+	/* fallback to failsafe values */
+	return 1;
+#else
+	/* stop boot process */
+	while (1)
+		cpu_relax();
+	/* not reached */
+	return 1;
+#endif
+
+#endif /* !CONFIG_TANGOX_XENV_READ */
+}
+
+
+/*
+ * helpers to access xenv configuration cached data
+ */
+
+/*
+ * enabled device query function
+ */
+#define BUILD_ENABLED(name, shift)					\
+int tangox_##name##_enabled(void)					\
+{									\
+	return (((enabled_devices >> shift) & 1) != 0) ? 1 : 0;	\
+} \
+EXPORT_SYMBOL(tangox_##name##_enabled);
+
+BUILD_ENABLED(isaide, ISAIDE_SHIFT)
+BUILD_ENABLED(bmide, BMIDE_SHIFT)
+BUILD_ENABLED(ir, IR_SHIFT)
+BUILD_ENABLED(fip, FIP_SHIFT)
+BUILD_ENABLED(usb, USB_SHIFT)
+BUILD_ENABLED(i2cm, I2CM_SHIFT)
+BUILD_ENABLED(i2cs, I2CS_SHIFT)
+BUILD_ENABLED(pci_host, PCIHOST_SHIFT)
+BUILD_ENABLED(sata, SATA_SHIFT)
+BUILD_ENABLED(gnet, GNET_SHIFT)
+
+int tangox_scard_enabled(int i)
+{
+#if defined(CONFIG_TANGO3)
+	if (i != 0)
+		return((enabled_devices >> SCARD1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> SCARD_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_ethernet_enabled(int i)
+{
+#if defined(CONFIG_TANGO3)
+	if (i != 0)
+		return((enabled_devices >> ETHERNET1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> ETHERNET_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_sdio_enabled(int i)
+{
+#if defined(CONFIG_TANGO3)
+	if (i != 0)
+		return((enabled_devices >> SDIO1_SHIFT) & 1) ? 1 : 0;
+#endif
+	return((enabled_devices >> SDIO_SHIFT) & 1) ? 1 : 0;
+}
+
+int tangox_pcidev_enabled(int idsel)
+{
+	if (!tangox_pci_host_enabled())
+		return 0;
+
+	idsel--;
+	return (((enabled_devices >> (idsel + PCI1_SHIFT)) & 1) != 0) ? 1 : 0;
+}
+
+int tangox_pcidev_irq_map(int pci_idsel, int int_num)
+{
+	int route;
+	int irq;
+
+	route = pcidev_irq_route[pci_idsel - 1];
+
+	/* int_num: 0-3 = INTA-D */
+	irq = (int)((route >> (int_num * 8)) & 0x3);
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_irq_map(void)
+{
+	int irq = 0;
+
+	if (tangox_isaide_enabled() == 0)
+		return(-1);
+	irq = isaide_irq;
+	if (irq >= 0)
+		irq += (IRQ_CONTROLLER_IRQ_BASE + LOG2_CPU_PCI_INTA);
+	return irq;
+}
+
+int tangox_isaide_cs_select(void)
+{
+        int i;
+        unsigned long cs_config = (gbus_read_reg32(REG_BASE_host_interface + PB_CS_config) >> 12) & 0xf;
+
+        if (tangox_isaide_enabled() == 0)
+                return(-1);
+
+        for (i = 0; i < 4; i++) {
+                if ((cs_config & 0x1) != 0)
+                        return(i);
+                else
+                        cs_config >>= 1;
+        }
+        return(-1);
+}
+
+int tangox_isaide_timing_slot(void)
+{
+        return(isaide_timing_slot & 0x7);
+}
+
+EXPORT_SYMBOL(tangox_isaide_irq_map);
+EXPORT_SYMBOL(tangox_isaide_cs_select);
+EXPORT_SYMBOL(tangox_isaide_timing_slot);
+EXPORT_SYMBOL(tangox_scard_enabled);
+EXPORT_SYMBOL(tangox_ethernet_enabled);
+EXPORT_SYMBOL(tangox_sdio_enabled);
+
+int tangox_ethernet_getmac(int idx, unsigned char *mac)
+{
+#if defined(CONFIG_TANGO3)
+	if (idx != 0) {
+		/* filter broadcast & multicast addresses */
+		if (mac_address1[0] == 0x01 || mac_address1[0] == 0xff)
+			memcpy(mac, def_mac_address, 6);
+		else
+			memcpy(mac, mac_address1, 6);
+		return 0;
+	}
+#endif
+	/* filter broadcast & multicast addresses */
+	if (mac_address[0] == 0x01 || mac_address[0] == 0xff)
+		memcpy(mac, def_mac_address, 6);
+	else
+		memcpy(mac, mac_address, 6);
+	return 0;
+}
+
+int tangox_uart_baudrate(int uart)
+{
+	return uart_baudrates[uart];
+}
+
+int tangox_uart_console_port(void)
+{
+	return uart_console_port;
+}
+
+int tangox_uart_enabled(int uart)
+{
+	return (((uart_used_ports >= 3) || (uart_console_port == uart)) ? 1 : 0);
+}
+
+int tangox_flash_get_info(int cs, u64 *size, unsigned int *part_count)
+{
+	if (cs > 3)
+		return 1;
+
+	*size = cs_flash_size[cs].uint64[0];
+	*part_count = 0;
+	if (cs_flash_size[cs].uint64[0] > 0)
+		*part_count = cs_flash_parts[cs];
+
+	return 0;
+}
+
+int tangox_flash_get_parts(int cs, u64 offset[], u64 size[])
+{
+	int i;
+
+	if (!cs_flash_size[cs].uint64[0])
+		return 1;
+
+	for (i = 0; i < cs_flash_parts[cs]; i++) {
+		offset[i] = flash_parts_offset[cs][i].uint64[0];
+		size[i] = flash_parts_size[cs][i].uint64[0];
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(tangox_flash_get_info);
+EXPORT_SYMBOL(tangox_flash_get_parts);
+
+#if defined(CONFIG_TANGO3)
+int tangox_flash_get_rsvd_pblk(int cs)
+{
+	if (cs > 3)
+		return 0;
+	else
+		return cs_rsvd_pblk[cs];
+}
+
+EXPORT_SYMBOL(tangox_flash_get_rsvd_pblk);
+#endif
+
+const char *tangox_xenv_cmdline(void)
+{
+	/* remove "" from command line */
+	if (xenv_cmdline[0] == '"') {
+		int len;
+
+		len = strlen(xenv_cmdline);
+		if (xenv_cmdline[len - 1] == '"')
+			xenv_cmdline[len - 1] = 0;
+		return xenv_cmdline + 1;
+	}
+	return xenv_cmdline;
+}
+
+#if defined(CONFIG_TANGO3)
+int tangox_get_sata_channel_cfg(unsigned int *cfg)
+{
+	*cfg = sata_channel_cfg;
+	return 0;
+}
+EXPORT_SYMBOL(tangox_get_sata_channel_cfg);
+#endif
+
+int tangox_get_scard_info(int scard_no, int *pin_5v, int *pin_cmd, int *pin_off)
+{
+#if defined(CONFIG_TANGO3)
+	if (scard_no != 0) {
+		*pin_5v = scard1_5v_pin;
+		*pin_off = scard1_off_pin;
+		*pin_cmd = scard1_cmd_pin;
+		return 0;
+	}
+#endif
+	*pin_5v = scard_5v_pin;
+	*pin_off = scard_off_pin;
+	*pin_cmd = scard_cmd_pin;
+	return 0;
+}
+
+/*
+ * show enabled devices according to xenv content
+ */
+void __init tangox_device_info(void)
+{
+	int i;
+
+	if (!xenv_gbus_addr) 
+		return;
+
+	printk(KERN_INFO "SMP86xx Enabled Devices under Linux/"
+	       "XENV 0x%08x = 0x%08x\n", xenv_gbus_addr, enabled_devices);
+
+	printk(KERN_INFO);
+	if (tangox_isaide_enabled())
+		printk(" ISA/IDE");
+	if (tangox_bmide_enabled())
+		printk(" BM/IDE");
+	if (tangox_pci_host_enabled())
+		printk(" PCIHost");
+	if (tangox_ethernet_enabled(0))
+		printk(" Ethernet");
+#if defined(CONFIG_TANGO3)
+	if (tangox_ethernet_enabled(1))
+		printk(" Ethernet1");
+#endif
+	if (tangox_ir_enabled())
+		printk(" IR");
+	if (tangox_fip_enabled())
+		printk(" FIP");
+	if (tangox_i2cm_enabled())
+		printk(" I2CM");
+	if (tangox_i2cs_enabled())
+		printk(" I2CS");
+	if (tangox_sdio_enabled(0))
+		printk(" SDIO");
+#if defined(CONFIG_TANGO3)
+	if (tangox_sdio_enabled(1))
+		printk(" SDIO1");
+#endif
+	if (tangox_usb_enabled())
+		printk(" USB");
+	for (i = 1; i <= 6; i++) {
+		if (tangox_pcidev_enabled(i))
+			printk(" PCIDev%d", i);
+	}
+	if (tangox_sata_enabled())
+		printk(" SATA");
+	if (tangox_scard_enabled(0))
+		printk(" SCARD");
+#if defined(CONFIG_TANGO3)
+	if (tangox_scard_enabled(1))
+		printk(" SCARD1");
+#endif
+	if (tangox_gnet_enabled())
+		printk(" GNET");
+	printk("\n");
+}
+
+#ifdef CONFIG_TANGO2
+void tangox_get_ps_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay)
+{
+	*pll3 = ps_pll3;
+	*pll2 = ps_pll2;
+	*pll1 = ps_pll1;
+	*pll0 = ps_pll0;
+	*mux = ps_mux;
+	*d0cfg = ps_d0cfg;
+	*d1cfg = ps_d1cfg;
+	*d0delay = ps_d0delay;
+	*d1delay = ps_d1delay;
+}
+
+void tangox_get_standby_config(u32 *pll3, u32 *pll2, u32 *pll1, u32 *pll0, u32 *mux, u32 *d0cfg, u32 *d0delay, u32 *d1cfg, u32 *d1delay, u32 *gpio_dir, u32 *gpio_data)
+{
+	*pll3 = standby_pll3;
+	*pll2 = standby_pll2;
+	*pll1 = standby_pll1;
+	*pll0 = standby_pll0;
+	*mux = standby_mux;
+	*d0cfg = standby_d0cfg;
+	*d1cfg = standby_d1cfg;
+	*d0delay = standby_d0delay;
+	*d1delay = standby_d1delay;
+	*gpio_dir = standby_gpiodir;
+	*gpio_data = standby_gpiodata;
+}
+#endif
+
+#if defined(CONFIG_TANGO3)
+void tangox_get_ps_config(unsigned long *pll2, unsigned long *pll0, unsigned long *mt3_hw_settings)
+{
+	*pll2 = ps_pll2;
+	*pll0 = ps_pll0;
+	memcpy(mt3_hw_settings, ps_mt3_hs, MT3_HS_SIZE);
+}
+
+void tangox_get_standby_config(unsigned long *pll2, unsigned long *pll0, unsigned long *mt3_hw_settings, u32 *gpio_dir, u32 *gpio_data)
+{
+	*pll2 = standby_pll2;
+	*pll0 = standby_pll0;
+	*gpio_dir = standby_gpiodir;
+	*gpio_data = standby_gpiodata;
+	memcpy(mt3_hw_settings, standby_mt3_hs, MT3_HS_SIZE);
+}
+#endif
+
+EXPORT_SYMBOL(tangox_ethernet_getmac);
+EXPORT_SYMBOL(tangox_get_scard_info);
+EXPORT_SYMBOL(tangox_get_ps_config);
+EXPORT_SYMBOL(tangox_get_standby_config);
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/xenv.h linux-2.6.29/arch/mips/tangox/xenv.h
--- linux-2.6.29.ref/arch/mips/tangox/xenv.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/xenv.h	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,99 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+
+/**
+  @file   xenv.h
+  @brief
+
+  The prototypes below act on a clear area respecting the xenv format.
+
+  (De)ciphering the  area, as well as committing  the changes (writing
+  the area to flash) are trivial add-ons on top of this API.
+
+  The underlying  implementation is not optimized for  speed (read and
+  write in  O(nrecords)). There  is no fragmentation  (data completely
+  rearranged at each write).
+
+  It is  not advised to repeatedly  act on flash stored  data, for the
+  device does  not support  unlimited read/write operations  (refer to
+  spec)
+
+  Power  loss when  committing the  changes cause  loss of  the stored
+  data.  This  can be avoided  by storing the  same data twice  to two
+  different sectors.
+
+  --------------------------------------------------------------------------
+  Specification   of   a   secure   storage   on   serial   flash   of
+  reboot-persistent data (xenv format)
+
+  We  describe a  way  to  concatenate (at  most  4KByte area  (12bits
+  limit)) variable  length records identified  by a string,  the `key'
+  (working much like Windows registry)
+
+  Page, seen as a byte array, is
+
+  0          4                   24                 env_size         4KB
+  | env_size | SHA-1 of following | rec0 | rec1 | .. | recn | xx xx .. |
+
+  The SHA-1 extent is env_size-24.
+
+  Description of a rec (bytes):
+
+  |4bits   12bits (2bytes)   | variable, NULL terminated | variable         |
+  attr     total record size   record name (string)        record value
+
+  attr =
+   XENV_ATTR_RW
+   XENV_ATTR_RO can be written once only but can be deleted
+   XENV_ATTR_OTP this record can be written once only and cannot be deleted
+  --------------------------------------------------------------------------
+
+  @author Emmanuel Michon
+  @date   2005-05-17
+*/
+
+#ifndef __XENV_H__
+#define __XENV_H__
+
+#include "setup.h"
+
+#define MAX_XENV_SIZE   16384
+
+/**
+   Check for compliance with xenv format
+
+   May be corrupted by:
+   - forgot to format
+   - power loss during sflash write
+   - intrusion
+
+   @param base
+   @param size
+   @return -ReturnValue-: env_size>=0 if valid, -1 if not.
+*/
+int xenv_isvalid(u32 *base, u32 maxsize);
+
+int xenv_foreach(u32 *base, u32 size,
+		 void (*cb)(char *recordname, void *data, u32 datasize));
+
+int xenv_get(u32 *base, u32 size, char *recordname, void *dst, u32 *datasize);
+int xenv_set(u32 *base, u32 size, char *recordname, void *src, u8 attr, u32 datasize);
+
+void xenv_dump(u32 *base, u32 size);
+
+#if defined(CONFIG_TANGO3)
+/*
+ * XENV sizes LRRO/LRRW
+ */
+#define MAX_LR_XENV2_RO 628
+#define MAX_LR_XENV2_RW 628
+#endif
+
+#endif // __XENV_H__
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/arch/mips/tangox/xenvkeys.h linux-2.6.29/arch/mips/tangox/xenvkeys.h
--- linux-2.6.29.ref/arch/mips/tangox/xenvkeys.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/arch/mips/tangox/xenvkeys.h	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,224 @@
+
+/*********************************************************************
+ Copyright (C) 2001-2007
+ Sigma Designs, Inc. 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License version 2 as
+ published by the Free Software Foundation.
+ *********************************************************************/
+/* 
+ * The keys defined in XENV, more can be added.
+ */
+
+#ifndef __XENV_KEYS_H__
+#define __XENV_KEYS_H__
+
+#define XENV_KEY_BOARD_ID           "a.board_id"
+#define XENV_KEY_CHIP_REV           "a.chip_rev"
+
+#define XENV_KEY_PREMUX             "a.premux"
+#define XENV_KEY_AVCLK_MUX          "a.avclk_mux"
+#define XENV_KEY_HOSTCLK_MUX        "a.hostclk_mux"
+#define XENV_KEY_IRQ_RISE_EDGE_LO   "a.irq_rise_edge_lo"
+#define XENV_KEY_IRQ_FALL_EDGE_LO   "a.irq_fall_edge_lo"
+#define XENV_KEY_GPIO_IRQ_MAP       "a.gpio_irq_map"
+
+#define XENV_KEY_DEF_BAUDRATE       "a.baudrate"
+#define XENV_KEY_CONSOLE_UART_PORT  "a.uart_console_port"
+#define XENV_KEY_UART_USED_PORTS    "a.uart_used_ports"
+
+#define XENV_KEY_PB_CS_CONFIG       "a.pb_cs_config"
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_PB_CS_CONFIG1      "a.pb_cs_config1"
+#define XENV_KEY_PB_CS_CTRL         "a.pb_cs_ctrl"
+#endif
+#define XENV_KEY_DEF_TIMING         "a.pb_def_timing"
+#define XENV_KEY_PB_TIMING0         "a.pb_timing0"
+#define XENV_KEY_PB_USE_TIMING0     "a.pb_use_timing0"
+#define XENV_KEY_PB_TIMING1         "a.pb_timing1"
+#define XENV_KEY_PB_USE_TIMING1     "a.pb_use_timing1"
+#define XENV_KEY_PB_TIMING2         "a.pb_timing2"
+#define XENV_KEY_PB_USE_TIMING2     "a.pb_use_timing2"
+#define XENV_KEY_PB_TIMING3         "a.pb_timing3"
+#define XENV_KEY_PB_USE_TIMING3     "a.pb_use_timing3"
+#define XENV_KEY_PB_TIMING4         "a.pb_timing4"
+#define XENV_KEY_PB_USE_TIMING4     "a.pb_use_timing4"
+#define XENV_KEY_PB_TIMING5         "a.pb_timing5"
+#define XENV_KEY_PB_USE_TIMING5     "a.pb_use_timing5"
+
+#define XENV_KEY_IRQ_RISE_EDGE_HI   "a.irq_rise_edge_hi"
+#define XENV_KEY_IRQ_FALL_EDGE_HI   "a.irq_fall_edge_hi"
+
+#define XENV_KEY_ENABLED_DEVICES    "a.enable_devices"
+
+#define XENV_KEY_ETH_MAC            "a.eth_mac"
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_ETH1_MAC           "a.eth1_mac"
+#endif
+
+#define XENV_KEY_SCARD_OFF          "a.scard_off_pin"
+#define XENV_KEY_SCARD_5V           "a.scard_5v_pin"
+#define XENV_KEY_SCARD_CMD          "a.scard_cmd_pin"
+
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_SCARD1_OFF         "a.scard1_off_pin"
+#define XENV_KEY_SCARD1_5V          "a.scard1_5v_pin"
+#define XENV_KEY_SCARD1_CMD         "a.scard1_cmd_pin"
+#endif
+
+#define XENV_KEY_ISAIDE_IRQ_ROUTE   "a.isaide_irq_route"
+#define XENV_KEY_ISAIDE_TIMING_SLOT "a.isaide_timing_slot"
+
+#define XENV_KEY_GPIO_DIR           "a.gpio_dir"
+#define XENV_KEY_GPIO_DATA          "a.gpio_data"
+
+#define XENV_KEY_LINUX_CMD          "a.linux_cmd"
+
+#define XENV_KEY_Z_BOOT_DEF         "z.default_boot"
+
+#define XENV_KEY_Z_PROD_TEST        "z.dt"
+#define XENV_KEY_Z_PROD_LOOPS       "z.prod_loops"
+#define XENV_KEY_Z_PROD_FTEST       "z.prod_ftest"
+#define XENV_KEY_Z_PROD_FSTART      "z.prod_fstart"
+#define XENV_KEY_Z_PROD_FEND        "z.prod_fend"
+#define XENV_KEY_Z_PROD_FSTEP       "z.prod_fstep"
+#define XENV_KEY_Z_PROD_RWIN        "z.prod_rwindow"
+#define XENV_KEY_Z_PROD_WWIN        "z.prod_wwindow"
+#define XENV_KEY_Z_PROD_CL          "z.prod_cl"
+#define XENV_KEY_Z_PROD_NBLOCKS     "z.prod_nblocks"
+
+#define XENV_KEY_YAMON_ENV          "y.env"
+#define XENV_KEY_YAMON_IPADDR       "y.ipaddr"
+#define XENV_KEY_YAMON_SUBNET       "y.subnetmask"
+#define XENV_KEY_YAMON_GATEWAY      "y.gateway"
+#define XENV_KEY_YAMON_START        "y.start"
+#define XENV_KEY_YAMON_STARTDELAY   "y.startdelay"
+
+#define XENV_KEYS_PCI_IRQ_ROUTE     "a.pcidev%d_irq_route"
+#define XENV_KEYS_CD_FREQUENCY      "a.cd%d_freq"
+#define XENV_KEYS_CD_DIV            "a.cd%d_div"
+#define XENV_KEYS_UART_GPIO_MODE    "a.uart%d_gpio_mode"
+#define XENV_KEYS_UART_GPIO_DIR     "a.uart%d_gpio_dir"
+#define XENV_KEYS_UART_GPIO_DATA    "a.uart%d_gpio_data"
+#define XENV_KEYS_UART_BAUDRATE     "a.uart%d_baudrate"
+#define XENV_KEYS_GPIO_PULSE        "a.gpio%d_pulse"
+
+#define XENV_KEYS_Z_BOOT_LOCATION   "z.boot%d"
+
+#define XENV_KEYS_CS_SIZE           "l.cs%d_size"
+#define XENV_KEYS_CS_PARTS          "l.cs%d_parts"
+
+#define XENV_KEYS_CS_PART_SIZE      "l.cs%d_part%d_size"
+#define XENV_KEYS_CS_PART_OFFSET    "l.cs%d_part%d_offset" 
+
+#if defined(CONFIG_TANGO3)
+#define XENV_KEYS_CS_RSVD_PBLK	    "a.cs%d_rsvd_pblk"
+#define XENV_KEY_SATA_CHANNEL_CFG   "a.sata_channel_cfg"
+#endif
+
+#ifdef CONFIG_TANGO2
+#define XENV_KEY_PS_PLL3            "a.ps.pll3"
+#define XENV_KEY_PS_PLL2            "a.ps.pll2"
+#define XENV_KEY_PS_PLL1            "a.ps.pll1"
+#define XENV_KEY_PS_PLL0            "a.ps.pll0"
+#define XENV_KEY_PS_MUX             "a.ps.mux"
+#define XENV_KEY_PS_D0CFG           "a.ps.d0cfg"
+#define XENV_KEY_PS_D1CFG           "a.ps.d1cfg"
+#define XENV_KEY_PS_D0DELAY         "a.ps.d0delay"
+#define XENV_KEY_PS_D1DELAY         "a.ps.d1delay"
+
+#define XENV_KEY_STANDBY_PLL3       "a.standby.pll3"
+#define XENV_KEY_STANDBY_PLL2       "a.standby.pll2"
+#define XENV_KEY_STANDBY_PLL1       "a.standby.pll1"
+#define XENV_KEY_STANDBY_PLL0       "a.standby.pll0"
+#define XENV_KEY_STANDBY_MUX        "a.standby.mux"
+#define XENV_KEY_STANDBY_D0CFG      "a.standby.d0cfg"
+#define XENV_KEY_STANDBY_D1CFG      "a.standby.d1cfg"
+#define XENV_KEY_STANDBY_D0DELAY    "a.standby.d0delay"
+#define XENV_KEY_STANDBY_D1DELAY    "a.standby.d1delay"
+#endif
+
+#if defined(CONFIG_TANGO3)
+#define XENV_KEY_PS_PLL2            "a.ps.pll2"
+#define XENV_KEY_PS_PLL0            "a.ps.pll0"
+#define XENV_KEY_PS_MT3_HS          "a.ps.mt3_hs"
+
+#define XENV_KEY_STANDBY_PLL2       "a.standby.pll2"
+#define XENV_KEY_STANDBY_PLL0       "a.standby.pll0"
+#define XENV_KEY_STANDBY_MT3_HS     "a.standby.mt3_hs"
+#endif
+
+#define XENV_KEY_STANDBY_GPIODIR    "a.standby.gpio_dir"
+#define XENV_KEY_STANDBY_GPIODATA   "a.standby.gpio_data"
+
+#ifndef CONFIG_SIGBLOCK_SUPPORT
+#define ISAIDE_SHIFT		0
+#define BMIDE_SHIFT		1
+#define PCIHOST_SHIFT		2
+#define ETHERNET_SHIFT		3
+#define IR_SHIFT		4
+#define FIP_SHIFT		5	
+#define I2CM_SHIFT		6
+#define I2CS_SHIFT		7
+#define SDIO_SHIFT		8
+#define USB_SHIFT		9
+#define PCI1_SHIFT		10
+#define PCI2_SHIFT		11
+#define PCI3_SHIFT		12
+#define PCI4_SHIFT		13
+#define PCI5_SHIFT		14
+#define PCI6_SHIFT		15
+#define SATA_SHIFT		16
+#define SCARD_SHIFT		17
+#define GNET_SHIFT		18
+#if defined(CONFIG_TANGO3)
+#define SCARD1_SHIFT		19
+#define ETHERNET1_SHIFT		20
+#define SDIO1_SHIFT		21
+#endif
+#endif
+
+/* Only used internally for LR_XENV2_RW and LR_XENV2_RO. Will be prefixed with z. when read off pfla */
+#if defined(CONFIG_TANGO3)
+/* lrrw */
+#define XENV_LRRW_ETH_MACL	     "lrrw.maclo"
+#define XENV_LRRW_ETH_MACH	     "lrrw.machi"
+#define XENV_LRRW_ETH1_MACL	     "lrrw.mac1lo"
+#define XENV_LRRW_ETH1_MACH	     "lrrw.mac1hi"
+#define XENV_LRRW_KERNEL_END	     "lrrw.kend"
+
+#define XENV_LRRW_RUAMM0_GA          "lrrw.ruamm0_ga"
+#define XENV_LRRW_RUAMM1_GA          "lrrw.ruamm1_ga"
+
+#define XENV_LRRW_0_UZDATA_OFFSET    "lrrw.0.uzdata_offset"
+#define XENV_LRRW_0_ZDATA_OFFSET     "lrrw.0.zdata_offset"
+#define XENV_LRRW_0_DSP_OFFSET       "lrrw.0.dsp_offset"
+#define XENV_LRRW_0_XPU_OFFSET       "lrrw.0.xpu_offset"
+#define XENV_LRRW_1_UZDATA_OFFSET    "lrrw.1.uzdata_offset"
+#define XENV_LRRW_1_ZDATA_OFFSET     "lrrw.1.zdata_offset"
+#define XENV_LRRW_1_DSP_OFFSET       "lrrw.1.dsp_offset"
+#define XENV_LRRW_1_XPU_OFFSET       "lrrw.1.xpu_offset"
+
+#define XENV_LRRW_CHANNEL_INDEX_GA   "lrrw.channel_index_ga"
+#define XENV_LRRW_CHANNEL_INDEX_SIZE "lrrw.channel_index_size"
+#define XENV_LRRW_IOS_GA             "lrrw.ios_ga"
+#define XENV_LRRW_IOS_SIZE           "lrrw.ios_size"
+#define XENV_LRRW_XOS_PUBLIC_GA      "lrrw.xos_public_ga"
+#define XENV_LRRW_XOS_PUBLIC_SIZE    "lrrw.xos_public_size"
+#define XENV_LRRW_IHAPI_GA           "lrrw.ihapi_ga"
+#define XENV_LRRW_MM_VERSION         "lrrw.mm_version"
+
+/* For handshaking and setup purpose */
+#define XENV_HS_RUAMM0_OFFSET	     "a.ruamm0_offset"
+#define XENV_HS_RUAMM1_OFFSET	     "a.ruamm1_offset"
+#define XENV_HS_XOS_PUBLIC_SIZE      "a.xos_public_size"
+#define XENV_HS_IOS_SIZE	     "a.ios_size"
+
+/* lrro */
+#define XENV_LRRO_LOCKED	     "lrro.locked"
+
+#endif
+
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/drivers/block/Kconfig linux-2.6.29/drivers/block/Kconfig
--- linux-2.6.29.ref/drivers/block/Kconfig	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/drivers/block/Kconfig	2011-05-24 12:39:48.733512002 -0700
@@ -358,6 +358,24 @@
 	  will prevent RAM block device backing store memory from being
 	  allocated from highmem (only a problem for highmem systems).
 
+config EMBEDDED_RAMDISK
+        bool "Embedded ramdisk"
+        default y
+        depends on BLK_DEV_INITRD=y && INITRAMFS_SOURCE=""
+        help
+          Select this option if you want to build the ramdisk image into the
+          the final kernel binary.
+
+config EMBEDDED_RAMDISK_IMAGE
+        string "File name of the ramdisk"
+        default ""
+        depends on EMBEDDED_RAMDISK=y
+        help
+          This is the filename of the ramdisk image to be built into the
+          kernel.  Relative pathnames are relative to arch/mips/ramdisk/.
+          The ramdisk image is not part of the kernel distribution; you must
+          provide one yourself.
+
 config CDROM_PKTCDVD
 	tristate "Packet writing on CD/DVD media"
 	depends on !UML
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/drivers/serial/8250.c linux-2.6.29/drivers/serial/8250.c
--- linux-2.6.29.ref/drivers/serial/8250.c	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/drivers/serial/8250.c	2011-05-24 12:39:48.733512002 -0700
@@ -39,6 +39,20 @@
 #include <linux/nmi.h>
 #include <linux/mutex.h>
 
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/rmdefs.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/rmdefs.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3.h>
+#endif
+
+#ifdef CONFIG_TANGOX
+extern unsigned long tangox_get_sysclock(void);
+#endif
+
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -388,13 +402,33 @@
 static unsigned int mem_serial_in(struct uart_port *p, int offset)
 {
 	offset = map_8250_in_reg(p, offset) << p->regshift;
+#ifdef CONFIG_TANGOX
+	{
+		unsigned long v;
+
+		/* no EFR on tango2/tango3 */
+		if (offset == (UART_EFR << p->regshift))
+			v = 0;
+		else
+			v = gbus_read_reg32((unsigned long)p->membase + offset);
+		return v;
+	}
+#else
 	return readb(p->membase + offset);
+#endif
 }
 
 static void mem_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = map_8250_out_reg(p, offset) << p->regshift;
+#ifdef CONFIG_TANGOX
+	/* no EFR on tango2/tango3 */
+	if (offset != (UART_EFR << p->regshift))
+		gbus_write_reg32((unsigned long)p->membase + offset, value);
+	return;
+#else
 	writeb(value, p->membase + offset);
+#endif
 }
 
 static void mem32_serial_out(struct uart_port *p, int offset, int value)
@@ -547,19 +581,6 @@
 #define serial_inp(up, offset)		serial_in(up, offset)
 #define serial_outp(up, offset, value)	serial_out(up, offset, value)
 
-/* Uart divisor latch read */
-static inline int _serial_dl_read(struct uart_8250_port *up)
-{
-	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
-}
-
-/* Uart divisor latch write */
-static inline void _serial_dl_write(struct uart_8250_port *up, int value)
-{
-	serial_outp(up, UART_DLL, value & 0xff);
-	serial_outp(up, UART_DLM, value >> 8 & 0xff);
-}
-
 #if defined(CONFIG_SERIAL_8250_AU1X00)
 /* Au1x00 haven't got a standard divisor latch */
 static int serial_dl_read(struct uart_8250_port *up)
@@ -595,7 +616,30 @@
 		_serial_dl_write(up, value);
 	}
 }
+#elif defined(CONFIG_TANGOX)
+static inline int serial_dl_read(struct uart_8250_port *up)
+{
+	return serial_inp(up, UART_DL);
+}
+
+/* Uart divisor latch write */
+static inline void serial_dl_write(struct uart_8250_port *up, int value)
+{
+	serial_outp(up, UART_DL, value);
+}
 #else
+/* Uart divisor latch read */
+static inline int _serial_dl_read(struct uart_8250_port *up)
+{
+	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
+}
+
+/* Uart divisor latch write */
+static inline void _serial_dl_write(struct uart_8250_port *up, int value)
+{
+	serial_outp(up, UART_DLL, value & 0xff);
+	serial_outp(up, UART_DLM, value >> 8 & 0xff);
+}
 #define serial_dl_read(up) _serial_dl_read(up)
 #define serial_dl_write(up, value) _serial_dl_write(up, value)
 #endif
@@ -774,6 +818,16 @@
 	old_lcr = serial_inp(p, UART_LCR);
 	serial_outp(p, UART_LCR, UART_LCR_DLAB);
 
+#ifdef CONFIG_TANGOX
+	old_dll = serial_inp(p, UART_DL) & 0xff;
+	old_dlm = serial_inp(p, UART_DL) >> 8;
+
+	serial_outp(p, UART_DL, 0);
+
+	id = serial_inp(p, UART_DL);
+
+	serial_outp(p, UART_DL, (old_dlm << 8) | old_dll);
+#else
 	old_dll = serial_inp(p, UART_DLL);
 	old_dlm = serial_inp(p, UART_DLM);
 
@@ -784,6 +838,7 @@
 
 	serial_outp(p, UART_DLL, old_dll);
 	serial_outp(p, UART_DLM, old_dlm);
+#endif
 	serial_outp(p, UART_LCR, old_lcr);
 
 	return id;
@@ -1076,7 +1131,6 @@
 	unsigned char status1, scratch, scratch2, scratch3;
 	unsigned char save_lcr, save_mcr;
 	unsigned long flags;
-
 	if (!up->port.iobase && !up->port.mapbase && !up->port.membase)
 		return;
 
@@ -1635,7 +1689,7 @@
 	struct hlist_head *h;
 	struct hlist_node *n;
 	struct irq_info *i;
-	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+	int ret, irq_flags = ((up->port.flags & UPF_SHARE_IRQ) ? IRQF_SHARED : 0);
 
 	mutex_lock(&hash_mutex);
 
@@ -2267,7 +2321,6 @@
 	 */
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
 	quot = serial8250_get_divisor(port, baud);
-
 	/*
 	 * Oxford Semi 952 rev B workaround
 	 */
@@ -2636,11 +2689,11 @@
 	struct uart_8250_port *up;
 	static int first = 1;
 	int i;
-
 	if (!first)
 		return;
 	first = 0;
 
+
 	for (i = 0; i < nr_uarts; i++) {
 		struct uart_8250_port *up = &serial8250_ports[i];
 
@@ -2768,7 +2821,13 @@
 static int __init serial8250_console_setup(struct console *co, char *options)
 {
 	struct uart_port *port;
+#ifdef CONFIG_TANGOX
+	extern int tangox_uart_baudrate(int uart);
+	extern int tangox_uart_console_port(void);
+	int baud = tangox_uart_baudrate(tangox_uart_console_port());
+#else
 	int baud = 9600;
+#endif
 	int bits = 8;
 	int parity = 'n';
 	int flow = 'n';
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/drivers/serial/8250_early.c linux-2.6.29/drivers/serial/8250_early.c
--- linux-2.6.29.ref/drivers/serial/8250_early.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/drivers/serial/8250_early.c	2011-05-24 12:39:48.733512002 -0700
@@ -106,8 +106,13 @@
 
 	lcr = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, lcr | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	dll = serial_in(port, UART_DL) & 0xff;
+	dlm = serial_in(port, UART_DL) >> 8;
+#else
 	dll = serial_in(port, UART_DLL);
 	dlm = serial_in(port, UART_DLM);
+#endif
 	serial_out(port, UART_LCR, lcr);
 
 	quot = (dlm << 8) | dll;
@@ -128,8 +133,12 @@
 	divisor = port->uartclk / (16 * device->baud);
 	c = serial_in(port, UART_LCR);
 	serial_out(port, UART_LCR, c | UART_LCR_DLAB);
+#ifdef CONFIG_TANGOX
+	serial_out(port, UART_DL, divisor & 0xffff);
+#else
 	serial_out(port, UART_DLL, divisor & 0xff);
 	serial_out(port, UART_DLM, (divisor >> 8) & 0xff);
+#endif
 	serial_out(port, UART_LCR, c & ~UART_LCR_DLAB);
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/drivers/serial/serial_core.c linux-2.6.29/drivers/serial/serial_core.c
--- linux-2.6.29.ref/drivers/serial/serial_core.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/drivers/serial/serial_core.c	2011-05-24 12:39:48.733512002 -0700
@@ -394,7 +394,8 @@
 			tty_termios_encode_baud_rate(termios, 9600, 9600);
 	}
 
-	return 0;
+//	return 0;
+	return baud;
 }
 
 EXPORT_SYMBOL(uart_get_baud_rate);
@@ -419,7 +420,8 @@
 	else
 		quot = (port->uartclk + (8 * baud)) / (16 * baud);
 
-	return quot;
+//	return quot;
+	return (quot ? quot : 1);
 }
 
 EXPORT_SYMBOL(uart_get_divisor);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/check.c linux-2.6.29/fs/partitions/check.c
--- linux-2.6.29.ref/fs/partitions/check.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/fs/partitions/check.c	2011-05-24 12:39:48.733512002 -0700
@@ -36,6 +36,7 @@
 #include "efi.h"
 #include "karma.h"
 #include "sysv68.h"
+#include "xenv_part.h"
 
 #ifdef CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(dev_t dev);
@@ -44,6 +45,9 @@
 int warn_no_part = 1; /*This is ugly: should make genhd removable media aware*/
 
 static int (*check_part[])(struct parsed_partitions *, struct block_device *) = {
+#ifdef CONFIG_XENV_PARTITION
+	xenv_partition,	/* Probe for XENV partition */
+#endif
 	/*
 	 * Probe partition formats with tables at disk address 0
 	 * that also have an ADFS boot block at 0xdc0.
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/efi.c linux-2.6.29/fs/partitions/efi.c
--- linux-2.6.29.ref/fs/partitions/efi.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/fs/partitions/efi.c	2011-05-24 12:39:48.733512002 -0700
@@ -1,7 +1,9 @@
 /************************************************************
  * EFI GUID Partition Table handling
- * Per Intel EFI Specification v1.02
- * http://developer.intel.com/technology/efi/efi.htm
+ *
+ * http://www.uefi.org/specs/
+ * http://www.intel.com/technology/efi/
+ *
  * efi.[ch] by Matt Domsch <Matt_Domsch@dell.com>
  *   Copyright 2000,2001,2002,2004 Dell Inc.
  *
@@ -92,6 +94,7 @@
  *
  ************************************************************/
 #include <linux/crc32.h>
+#include <linux/math64.h>
 #include "check.h"
 #include "efi.h"
 
@@ -141,7 +144,8 @@
 {
 	if (!bdev || !bdev->bd_inode)
 		return 0;
-	return (bdev->bd_inode->i_size >> 9) - 1ULL;
+	return div_u64(bdev->bd_inode->i_size,
+		       bdev_hardsect_size(bdev)) - 1ULL;
 }
 
 static inline int
@@ -188,6 +192,7 @@
 read_lba(struct block_device *bdev, u64 lba, u8 * buffer, size_t count)
 {
 	size_t totalreadcount = 0;
+	sector_t n = lba * (bdev_hardsect_size(bdev) / 512);
 
 	if (!bdev || !buffer || lba > last_lba(bdev))
                 return 0;
@@ -195,7 +200,7 @@
 	while (count) {
 		int copied = 512;
 		Sector sect;
-		unsigned char *data = read_dev_sector(bdev, lba++, &sect);
+		unsigned char *data = read_dev_sector(bdev, n++, &sect);
 		if (!data)
 			break;
 		if (copied > count)
@@ -257,15 +262,16 @@
 alloc_read_gpt_header(struct block_device *bdev, u64 lba)
 {
 	gpt_header *gpt;
+	unsigned ssz = bdev_hardsect_size(bdev);
+
 	if (!bdev)
 		return NULL;
 
-	gpt = kzalloc(sizeof (gpt_header), GFP_KERNEL);
+	gpt = kzalloc(ssz, GFP_KERNEL);
 	if (!gpt)
 		return NULL;
 
-	if (read_lba(bdev, lba, (u8 *) gpt,
-		     sizeof (gpt_header)) < sizeof (gpt_header)) {
+	if (read_lba(bdev, lba, (u8 *) gpt, ssz) < ssz) {
 		kfree(gpt);
                 gpt=NULL;
 		return NULL;
@@ -601,6 +607,7 @@
 	gpt_header *gpt = NULL;
 	gpt_entry *ptes = NULL;
 	u32 i;
+	unsigned ssz = bdev_hardsect_size(bdev) / 512;
 
 	if (!find_valid_gpt(bdev, &gpt, &ptes) || !gpt || !ptes) {
 		kfree(gpt);
@@ -611,13 +618,14 @@
 	pr_debug("GUID Partition Table is valid!  Yea!\n");
 
 	for (i = 0; i < le32_to_cpu(gpt->num_partition_entries) && i < state->limit-1; i++) {
+		u64 start = le64_to_cpu(ptes[i].starting_lba);
+		u64 size = le64_to_cpu(ptes[i].ending_lba) -
+			   le64_to_cpu(ptes[i].starting_lba) + 1ULL;
+
 		if (!is_pte_valid(&ptes[i], last_lba(bdev)))
 			continue;
 
-		put_partition(state, i+1, le64_to_cpu(ptes[i].starting_lba),
-				 (le64_to_cpu(ptes[i].ending_lba) -
-                                  le64_to_cpu(ptes[i].starting_lba) +
-				  1ULL));
+		put_partition(state, i+1, start * ssz, size * ssz);
 
 		/* If this is a RAID volume, tell md */
 		if (!efi_guidcmp(ptes[i].partition_type_guid,
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/Kconfig linux-2.6.29/fs/partitions/Kconfig
--- linux-2.6.29.ref/fs/partitions/Kconfig	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/fs/partitions/Kconfig	2011-05-24 12:39:48.733512002 -0700
@@ -249,3 +249,13 @@
 	  partition table format used by Motorola Delta machines (using
 	  sysv68).
 	  Otherwise, say N.
+
+config XENV_PARTITION
+	bool "XENV partition support" if PARTITION_ADVANCED 
+	depends on TANGO3
+	default TANGOX_XENV_READ 
+	help
+	  Say Y here if you would like to be able to read the partition
+	  information from XENV.
+	  Otherwise, say N.
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/mac.c linux-2.6.29/fs/partitions/mac.c
--- linux-2.6.29.ref/fs/partitions/mac.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/fs/partitions/mac.c	2011-05-24 12:39:48.733512002 -0700
@@ -33,7 +33,7 @@
 	Sector sect;
 	unsigned char *data;
 	int blk, blocks_in_map;
-	unsigned secsize;
+	sector_t secsize;
 #ifdef CONFIG_PPC_PMAC
 	int found_root = 0;
 	int found_root_goodness = 0;
@@ -62,7 +62,7 @@
 	printk(" [mac]");
 	blocks_in_map = be32_to_cpu(part->map_count);
 	for (blk = 1; blk <= blocks_in_map; ++blk) {
-		int pos = blk * secsize;
+		sector_t pos = blk * secsize;
 		put_dev_sector(sect);
 		data = read_dev_sector(bdev, pos/512, &sect);
 		if (!data)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/Makefile linux-2.6.29/fs/partitions/Makefile
--- linux-2.6.29.ref/fs/partitions/Makefile	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/fs/partitions/Makefile	2011-05-24 12:39:48.733512002 -0700
@@ -18,3 +18,4 @@
 obj-$(CONFIG_EFI_PARTITION) += efi.o
 obj-$(CONFIG_KARMA_PARTITION) += karma.o
 obj-$(CONFIG_SYSV68_PARTITION) += sysv68.o
+obj-$(CONFIG_XENV_PARTITION) += xenv_part.o
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/msdos.c linux-2.6.29/fs/partitions/msdos.c
--- linux-2.6.29.ref/fs/partitions/msdos.c	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/fs/partitions/msdos.c	2011-05-24 12:39:48.733512002 -0700
@@ -31,14 +31,17 @@
  */
 #include <asm/unaligned.h>
 
-#define SYS_IND(p)	(get_unaligned(&p->sys_ind))
-#define NR_SECTS(p)	({ __le32 __a =	get_unaligned(&p->nr_sects);	\
-				le32_to_cpu(__a); \
-			})
-
-#define START_SECT(p)	({ __le32 __a =	get_unaligned(&p->start_sect);	\
-				le32_to_cpu(__a); \
-			})
+#define SYS_IND(p)	get_unaligned(&p->sys_ind)
+
+static inline sector_t nr_sects(struct partition *p)
+{
+	return (sector_t)get_unaligned_le32(&p->nr_sects);
+}
+
+static inline sector_t start_sect(struct partition *p)
+{
+	return (sector_t)get_unaligned_le32(&p->start_sect);
+}
 
 static inline int is_extended_partition(struct partition *p)
 {
@@ -104,13 +107,13 @@
 
 static void
 parse_extended(struct parsed_partitions *state, struct block_device *bdev,
-			u32 first_sector, u32 first_size)
+			sector_t first_sector, sector_t first_size)
 {
 	struct partition *p;
 	Sector sect;
 	unsigned char *data;
-	u32 this_sector, this_size;
-	int sector_size = bdev_hardsect_size(bdev) / 512;
+	sector_t this_sector, this_size;
+	sector_t sector_size = bdev_hardsect_size(bdev) / 512;
 	int loopct = 0;		/* number of links followed
 				   without finding a data partition */
 	int i;
@@ -145,14 +148,14 @@
 		 * First process the data partition(s)
 		 */
 		for (i=0; i<4; i++, p++) {
-			u32 offs, size, next;
-			if (!NR_SECTS(p) || is_extended_partition(p))
+			sector_t offs, size, next;
+			if (!nr_sects(p) || is_extended_partition(p))
 				continue;
 
 			/* Check the 3rd and 4th entries -
 			   these sometimes contain random garbage */
-			offs = START_SECT(p)*sector_size;
-			size = NR_SECTS(p)*sector_size;
+			offs = start_sect(p)*sector_size;
+			size = nr_sects(p)*sector_size;
 			next = this_sector + offs;
 			if (i >= 2) {
 				if (offs + size > this_size)
@@ -179,13 +182,13 @@
 		 */
 		p -= 4;
 		for (i=0; i<4; i++, p++)
-			if (NR_SECTS(p) && is_extended_partition(p))
+			if (nr_sects(p) && is_extended_partition(p))
 				break;
 		if (i == 4)
 			goto done;	 /* nothing left to do */
 
-		this_sector = first_sector + START_SECT(p) * sector_size;
-		this_size = NR_SECTS(p) * sector_size;
+		this_sector = first_sector + start_sect(p) * sector_size;
+		this_size = nr_sects(p) * sector_size;
 		put_dev_sector(sect);
 	}
 done:
@@ -197,7 +200,7 @@
 
 static void
 parse_solaris_x86(struct parsed_partitions *state, struct block_device *bdev,
-			u32 offset, u32 size, int origin)
+			sector_t offset, sector_t size, int origin)
 {
 #ifdef CONFIG_SOLARIS_X86_PARTITION
 	Sector sect;
@@ -244,7 +247,7 @@
  */
 static void
 parse_bsd(struct parsed_partitions *state, struct block_device *bdev,
-		u32 offset, u32 size, int origin, char *flavour,
+		sector_t offset, sector_t size, int origin, char *flavour,
 		int max_partitions)
 {
 	Sector sect;
@@ -263,7 +266,7 @@
 	if (le16_to_cpu(l->d_npartitions) < max_partitions)
 		max_partitions = le16_to_cpu(l->d_npartitions);
 	for (p = l->d_partitions; p - l->d_partitions < max_partitions; p++) {
-		u32 bsd_start, bsd_size;
+		sector_t bsd_start, bsd_size;
 
 		if (state->next == state->limit)
 			break;
@@ -290,7 +293,7 @@
 
 static void
 parse_freebsd(struct parsed_partitions *state, struct block_device *bdev,
-		u32 offset, u32 size, int origin)
+		sector_t offset, sector_t size, int origin)
 {
 #ifdef CONFIG_BSD_DISKLABEL
 	parse_bsd(state, bdev, offset, size, origin,
@@ -300,7 +303,7 @@
 
 static void
 parse_netbsd(struct parsed_partitions *state, struct block_device *bdev,
-		u32 offset, u32 size, int origin)
+		sector_t offset, sector_t size, int origin)
 {
 #ifdef CONFIG_BSD_DISKLABEL
 	parse_bsd(state, bdev, offset, size, origin,
@@ -310,7 +313,7 @@
 
 static void
 parse_openbsd(struct parsed_partitions *state, struct block_device *bdev,
-		u32 offset, u32 size, int origin)
+		sector_t offset, sector_t size, int origin)
 {
 #ifdef CONFIG_BSD_DISKLABEL
 	parse_bsd(state, bdev, offset, size, origin,
@@ -324,7 +327,7 @@
  */
 static void
 parse_unixware(struct parsed_partitions *state, struct block_device *bdev,
-		u32 offset, u32 size, int origin)
+		sector_t offset, sector_t size, int origin)
 {
 #ifdef CONFIG_UNIXWARE_DISKLABEL
 	Sector sect;
@@ -348,7 +351,8 @@
 
 		if (p->s_label != UNIXWARE_FS_UNUSED)
 			put_partition(state, state->next++,
-						START_SECT(p), NR_SECTS(p));
+				      le32_to_cpu(p->start_sect),
+				      le32_to_cpu(p->nr_sects));
 		p++;
 	}
 	put_dev_sector(sect);
@@ -363,7 +367,7 @@
  */
 static void
 parse_minix(struct parsed_partitions *state, struct block_device *bdev,
-		u32 offset, u32 size, int origin)
+		sector_t offset, sector_t size, int origin)
 {
 #ifdef CONFIG_MINIX_SUBPARTITION
 	Sector sect;
@@ -390,7 +394,7 @@
 			/* add each partition in use */
 			if (SYS_IND(p) == MINIX_PARTITION)
 				put_partition(state, state->next++,
-					      START_SECT(p), NR_SECTS(p));
+					      start_sect(p), nr_sects(p));
 		}
 		printk(" >\n");
 	}
@@ -401,7 +405,7 @@
 static struct {
 	unsigned char id;
 	void (*parse)(struct parsed_partitions *, struct block_device *,
-			u32, u32, int);
+			sector_t, sector_t, int);
 } subtypes[] = {
 	{FREEBSD_PARTITION, parse_freebsd},
 	{NETBSD_PARTITION, parse_netbsd},
@@ -415,7 +419,8 @@
  
 int msdos_partition(struct parsed_partitions *state, struct block_device *bdev)
 {
-	int sector_size = bdev_hardsect_size(bdev) / 512;
+	sector_t sector_size = bdev_hardsect_size(bdev) / 512;
+
 	Sector sect;
 	unsigned char *data;
 	struct partition *p;
@@ -483,14 +488,21 @@
 
 	state->next = 5;
 	for (slot = 1 ; slot <= 4 ; slot++, p++) {
-		u32 start = START_SECT(p)*sector_size;
-		u32 size = NR_SECTS(p)*sector_size;
+		sector_t start = start_sect(p)*sector_size;
+		sector_t size = nr_sects(p)*sector_size;
 		if (!size)
 			continue;
 		if (is_extended_partition(p)) {
-			/* prevent someone doing mkfs or mkswap on an
-			   extended partition, but leave room for LILO */
-			put_partition(state, slot, start, size == 1 ? 1 : 2);
+			/*
+			 * prevent someone doing mkfs or mkswap on an
+			 * extended partition, but leave room for LILO
+			 * FIXME: this uses one logical sector for > 512b
+			 * sector, although it may not be enough/proper.
+			 */
+			sector_t n = 2;
+			n = min(size, max(sector_size, n));
+			put_partition(state, slot, start, n);
+
 			printk(" <");
 			parse_extended(state, bdev, start, size);
 			printk(" >");
@@ -513,7 +525,7 @@
 		unsigned char id = SYS_IND(p);
 		int n;
 
-		if (!NR_SECTS(p))
+		if (!nr_sects(p))
 			continue;
 
 		for (n = 0; subtypes[n].parse && id != subtypes[n].id; n++)
@@ -521,8 +533,8 @@
 
 		if (!subtypes[n].parse)
 			continue;
-		subtypes[n].parse(state, bdev, START_SECT(p)*sector_size,
-						NR_SECTS(p)*sector_size, slot);
+		subtypes[n].parse(state, bdev, start_sect(p)*sector_size,
+						nr_sects(p)*sector_size, slot);
 	}
 	put_dev_sector(sect);
 	return 1;
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/xenv_part.c linux-2.6.29/fs/partitions/xenv_part.c
--- linux-2.6.29.ref/fs/partitions/xenv_part.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/fs/partitions/xenv_part.c	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,54 @@
+
+/*
+ * Converting XENV partition information to psudo HDD-like partitions.
+ */
+
+/* Only applicable to Tango3 */
+#include <asm/io.h>
+#if defined(CONFIG_TANGO3)
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/hardware.h>
+#else
+#error Not supported platform.
+#endif
+#include "check.h"
+
+#include "xenv_part.h"
+
+/* XENV query function prototypes */
+extern int tangox_flash_get_info(int cs, u64 *size, unsigned int *part_count);
+extern int tangox_flash_get_parts(int cs, u64 offset[], u64 size[]);
+
+int xenv_partition(struct parsed_partitions *state, struct block_device *bdev)
+{
+	struct xenv_disk_marker *sdisk = bdev->bd_disk->private_data;
+	unsigned int cs, cs_part;
+	u64 cs_size, offsets[SDND_MINORS], sizes[SDND_MINORS];
+	int i;
+
+	if (sdisk == NULL)
+		goto out;
+	else if (sdisk->magic != SDND_MAGIC)
+		goto out;
+	else if ((cs = sdisk->cs) >= SDND_MAX_CS)
+		goto out;
+
+	tangox_flash_get_info(cs, &cs_size, &cs_part);
+
+	if ((cs_part == 0) || (cs_size == 0)) 
+		goto out;
+	else if (cs_part > (SDND_MINORS - 2))
+		cs_part = SDND_MINORS - 2;
+
+	tangox_flash_get_parts(cs, &offsets[0], &sizes[0]);
+	state->limit = SDND_MINORS - 1;
+
+	for (i = 0; i < cs_part; i++) 
+		put_partition(state, i + 1, offsets[i] / KERNEL_SECTOR_SIZE, sizes[i] / KERNEL_SECTOR_SIZE);
+
+	return 1;
+
+out:
+	return 0;
+}
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/fs/partitions/xenv_part.h linux-2.6.29/fs/partitions/xenv_part.h
--- linux-2.6.29.ref/fs/partitions/xenv_part.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/fs/partitions/xenv_part.h	2011-05-24 12:39:48.733512002 -0700
@@ -0,0 +1,7 @@
+
+#ifndef __XENV_PART_H__
+#define __XENV_PART_H__
+
+int xenv_partition(struct parsed_partitions *state, struct block_device *bdev);
+
+#endif /* __XENV_PART_H__ */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/include/linux/jiffies.h linux-2.6.29/include/linux/jiffies.h
--- linux-2.6.29.ref/include/linux/jiffies.h	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/include/linux/jiffies.h	2011-05-24 12:39:48.733512002 -0700
@@ -164,7 +164,11 @@
  * Have the 32 bit jiffies value wrap 5 minutes after boot
  * so jiffies wrap bugs show up earlier.
  */
+#if defined(CONFIG_PRINTK_TIME)
+#define INITIAL_JIFFIES 0
+#else
 #define INITIAL_JIFFIES ((unsigned long)(unsigned int) (-300*HZ))
+#endif
 
 /*
  * Change timeval to jiffies, trying to avoid the
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/include/linux/serial_reg.h linux-2.6.29/include/linux/serial_reg.h
--- linux-2.6.29.ref/include/linux/serial_reg.h	2009-06-16 04:17:03.000000000 -0700
+++ linux-2.6.29/include/linux/serial_reg.h	2011-05-24 12:39:48.733512002 -0700
@@ -15,12 +15,44 @@
 #define _LINUX_SERIAL_REG_H
 
 /*
- * DLAB=0
+ * SMP8xxx has 16550 uarts, but registers are a little bit different...
  */
+#ifdef CONFIG_TANGOX
+
 #define UART_RX		0	/* In:  Receive buffer */
-#define UART_TX		0	/* Out: Transmit buffer */
+#define UART_TX		1	/* Out: Transmit buffer */
+#define UART_IER	2	/* Out: Interrupt Enable Register */
+#define UART_IIR	3	/* In:  Interrupt ID Register */
+#define UART_FCR	4	/* Out: FIFO Control Register */
+#define UART_LCR	5	/* Out: Line Control Register */
+#define UART_MCR	6	/* Out: Modem Control Register */
+#define UART_LSR	7	/* In:  Line Status Register */
+#define UART_MSR	8	/* In:  Modem Status Register */
+#define UART_SCR	9	/* I/O: Scratch Register */
+
+/* EFR does not exist on TANGOX,  we use a magic to catch accesses and
+ * make them nop */
+#define UART_EFR	42
+
+#else
 
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
 #define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+#endif
+
+/*
+ * DLAB=0
+ */
 #define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
 #define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
 #define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
@@ -30,7 +62,6 @@
  */
 #define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
 
-#define UART_IIR	2	/* In:  Interrupt ID Register */
 #define UART_IIR_NO_INT		0x01 /* No interrupts pending */
 #define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
 #define UART_IIR_MSI		0x00 /* Modem status interrupt */
@@ -40,7 +71,6 @@
 
 #define UART_IIR_BUSY		0x07 /* DesignWare APB Busy Detect */
 
-#define UART_FCR	2	/* Out: FIFO Control Register */
 #define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
 #define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
 #define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
@@ -83,7 +113,6 @@
 #define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
 #define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
 
-#define UART_LCR	3	/* Out: Line Control Register */
 /*
  * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
  * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
@@ -99,7 +128,6 @@
 #define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
 #define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
 
-#define UART_MCR	4	/* Out: Modem Control Register */
 #define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
 #define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
 #define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
@@ -110,7 +138,6 @@
 #define UART_MCR_RTS		0x02 /* RTS complement */
 #define UART_MCR_DTR		0x01 /* DTR complement */
 
-#define UART_LSR	5	/* In:  Line Status Register */
 #define UART_LSR_TEMT		0x40 /* Transmitter empty */
 #define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
 #define UART_LSR_BI		0x10 /* Break interrupt indicator */
@@ -120,7 +147,6 @@
 #define UART_LSR_DR		0x01 /* Receiver data ready */
 #define UART_LSR_BRK_ERROR_BITS	0x1E /* BI, FE, PE, OE bits */
 
-#define UART_MSR	6	/* In:  Modem Status Register */
 #define UART_MSR_DCD		0x80 /* Data Carrier Detect */
 #define UART_MSR_RI		0x40 /* Ring Indicator */
 #define UART_MSR_DSR		0x20 /* Data Set Ready */
@@ -131,18 +157,25 @@
 #define UART_MSR_DCTS		0x01 /* Delta CTS */
 #define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
 
-#define UART_SCR	7	/* I/O: Scratch Register */
 
 /*
  * DLAB=1
  */
+
+/*
+ * SMP8xxx has DLM and DLM in one register
+ */
+#ifdef CONFIG_TANGOX
+#define UART_DL		10
+#define UART_CLKSEL	11	/* Clock selection */
+#else
 #define UART_DLL	0	/* Out: Divisor Latch Low */
 #define UART_DLM	1	/* Out: Divisor Latch High */
+#endif
 
 /*
  * LCR=0xBF (or DLAB=1 for 16C660)
  */
-#define UART_EFR	2	/* I/O: Extended Features Register */
 #define UART_EFR_CTS		0x80 /* CTS flow control */
 #define UART_EFR_RTS		0x40 /* RTS flow control */
 #define UART_EFR_SCD		0x20 /* Special character detect */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/Makefile linux-2.6.29/Makefile
--- linux-2.6.29.ref/Makefile	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/Makefile	2011-05-24 12:39:48.733512002 -0700
@@ -4,6 +4,8 @@
 EXTRAVERSION = .6
 NAME = Temporary Tasmanian Devil
 
+RELEASE_NAME	:= -27
+
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
 # More info can be located in ./README
@@ -192,7 +194,7 @@
 
 export KBUILD_BUILDHOST := $(SUBARCH)
 ARCH		?= mips
-CROSS_COMPILE	?=
+CROSS_COMPILE	?= mipsel-linux-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
@@ -352,7 +354,7 @@
 
 # Read KERNELRELEASE from include/config/kernel.release (if it exists)
 KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
-KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(RELEASE_NAME)
 
 export VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION
 export ARCH SRCARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC
@@ -500,7 +502,7 @@
 PHONY += include/config/auto.conf
 
 include/config/auto.conf:
-	$(Q)test -e include/linux/autoconf.h -a -e $@ || (		\
+	-@$(Q)test -e include/linux/autoconf.h -a -e $@ || (		\
 	echo;								\
 	echo "  ERROR: Kernel configuration is invalid.";		\
 	echo "         include/linux/autoconf.h or $@ are missing.";	\
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/mm/page_alloc.c linux-2.6.29/mm/page_alloc.c
--- linux-2.6.29.ref/mm/page_alloc.c	2011-05-24 11:56:22.000000000 -0700
+++ linux-2.6.29/mm/page_alloc.c	2011-05-24 12:39:48.733512002 -0700
@@ -1478,6 +1478,7 @@
 	int alloc_flags;
 	unsigned long did_some_progress;
 	unsigned long pages_reclaimed = 0;
+	int num_retries = 0;
 
 	might_sleep_if(wait);
 
@@ -1661,6 +1662,12 @@
 
 nopage:
 	if (!(gfp_mask & __GFP_NOWARN) && printk_ratelimit()) {
+		if (wait && !in_atomic() && !in_interrupt() && (++num_retries < 16)) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ);
+			goto rebalance;
+		}
+
 		printk(KERN_WARNING "%s: page allocation failure."
 			" order:%d, mode:0x%x\n",
 			p->comm, order, gfp_mask);
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin linux-2.6.29.ref/README.1001.tangox.patch linux-2.6.29/README.1001.tangox.patch
--- linux-2.6.29.ref/README.1001.tangox.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.29/README.1001.tangox.patch	2011-05-24 12:46:27.173691619 -0700
@@ -0,0 +1,20 @@
+Feature:
+--------
+Core support for SMP86xx chips
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+
+Primary author:
+---------------
+YH Lin/External(Jean-Francois Thibert)
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES2 or above.
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
+CONFIG_TANGOX (CONFIG_TANGO2 or CONFIG_TANGO3)
